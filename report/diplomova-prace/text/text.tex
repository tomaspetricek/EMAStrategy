% Do not forget to include Introduction
%---------------------------------------------------------------
% \chapter{Introduction}
% uncomment the following line to create an unnumbered chapter
\chapter*{Introduction}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

Backtesting je nezbytnou součástí při vývoji obchodní strategie.
Ukazuje, jak by si strategie vedla, kdyby byla nasazena v minulosti.
Cílem je lépe pochopit fungování dané strategie, zjistit, kde jsou její úskalí a ideálně je opravit před nasazením do produkce.
Strategie jsou často parametrizované a při obchodování s různými aktivy mohou fungovat různé kombinace hodnot.
Pro maximalizaci ziskovosti strategie a snížení rizik je zapotřebí rychlý a spolehlivý způsob optimalizace těchto parametrů \cite{efficient-backtesting}.

Nejjednodušší a časově nejnáročnější způsob, jak najít optimální nastavení, by bylo prohledat všechny možné kombinace.
Největší výhodou tohoto přístupu je, že zaručuje nalezení nejlepšího možného řešení, nicméně je v praxi nepoužitelný pro velké množství možností, protože neskončí v přiměřeně krátké době \cite{efficient-backtesting}.

\chapter{Design}

\subsection{Jmenné konvence}
Konvence pojmenování jsou převzaty převážně z \textit{STL} a \textit{Boost} knihoven.
Názvy tříd a funkcí používají \texttt{snake\_case}.
Metody nastavení a čtení atributů třídy nepoužívají \texttt{set} a \texttt{get} ve svém názvu, jsou jednoduše odlišeni tak, že gettery neberou žádný parametr a settery berou více než jeden.
Názvy šablon a konceptů používají \texttt{CamelCase}.
Soukromé atributy třídy končí podtržítkem.

\subsection{Uspořádání projektu}
Projekt je rozdělen do 3 hlavních adresářů: \textit{include}, \textit{src} a \textit{test}.
Adresář \textit{include} obsahuje obchodovací framework a vybrané hlavičkové soubory z knihovny CppCoro.
Organizace frameworku je inspirovaná knihovnou \textit{Boost.Asio}.
Definice a deklarace tříd jsou uloženy společně v jednom souboru s příponou \textit{.hpp}.
Hierarchie složek se řídí jmennými prostory, například třídu \texttt{trading::bazooka::long\_strategy} lze nalézt v souboru \textit{/include/trading/bazooka/long\_strategy}.
Framework lze zahrnout jako celek pomocí \textit{trading.hpp} nebo jednotlivě po souborech.

Adresář \textit{src} se skládá ze souboru \textit{main.cpp}, Jypiter Notebooků používaných pro vizualizaci, vstupních a výstupních dat.
Testy jsou organizovány stejně jako třídy obchodovacího frameworku.
Projekt je kompilován pomocí souborů \textit{CMakeLists.txt}, které obsahují seznam souborů ke kompilaci, nastavení kompilátoru a informace pro hledání externích knihoven.
Vytváří 2 spustitelné soubory \textit{backesting} pro použití optimalizátorů a \textit{test\_} pro provádění testů.

\chapter{Simulace obchodování}
Simulace obchodování byla inspirována kryptoměnovou burzou \textit{Binance}.
Byly přijaty některé konvence pojmenování, jako je otevírání a zavírání pozic.
Otevření longové pozice znamená nákup aktiva, nicméně otevření shortové pozice znamená jeho prodej.
Prodej a nákup tedy jdou proti sobě, a proto je lepší používat termíny otevření a uzavření.

Je také běžné zaměnitelně říkat, že obchod nebo pozice jsou otevřené.
Na \textit{Binance} je možné si vyžádat historii uskutečněných obchodů.
Vygenerované obchody jsou pouze transakce provedené mezi dvěma obchodníky.
Proto je lepší používat termín pozice, který představuje seznam souvisejících otevřených a uzavřených obchodů.

% Účet je na kryptoburzách reprezentován jako peněženka, která uchovává množství nakoupených aktiv.

\section{Bazooka}
Strategie s názvem \textit{Bazooka} byla rozdělena do 2 tříd: \texttt{bazooka::strategy} a \texttt{bazooka::manager}.
Důvodem rozdělení bylo oddělení zájmů.
Třída \texttt{bazooka::strategy} dělá rozhodnutí a třída \texttt{bazooka::manager} je realizuje.
V současné době je implementována burza podporující pouze longové obchody, ale pokud by v budoucnu existovala např. \texttt{futures::market} burza podporující pákové obchody, bylo by nutné použít jiný typ manažera, nicméně strategie by zůstala stejná.
Jsou dány dohromady pomocí třídy \texttt{trader}.

Hodnoty nákupních velikostí a úrovní jsou uloženy jako pole zlomků pevné délky.
Zlomky jsou reperezentovány pomocí třídy \texttt{fraction}, která je inspirována třídou \texttt{boost::rational}.
Je však mnohem jednodušší a méně obecná.
Předpokládá, na rozdíl od \texttt{boost::rational}, že zlomky, mezi kterými se provádějí aritmetické operace, mají stejného jmenovatele.
Porušení tohoto předpokladu vede k nedefinovanému chování.
Zlomky jsou uloženy v instanci třídy \texttt{std::array}, což také znamená, že velikost sekvence musí být známa v době kompilace.

\subsection{Strategie}
% dát pryč nebo přidat long/short strategy
Strategie je implementována pomocí třídy \texttt{bazooka::strategy}.
Má jeden parametr šablony třídy \texttt{n\_levels}, který uvádí počet úrovní nákupu.
Při inicializaci přebírá parametry: vstupní a výstupní indikátor a úrovně nákupu.
V průběhu inicializace jsou také validovány nákupní úrovně, pokud nesplňují požadavky, je vyhozena výjimka \texttt{std::invalid\_argument}.

Účelem třídy je činit rozhodnutí a k tomu má dvě metody \texttt{should\_open} a \texttt{should\_close}.
Obě metody používají indikátory, aby zjistily, zda byly splněny podmínky pro vyslání signálu.
Vracejí booleovskou hodnotu, která určuje, jestli by měla být akce provedena.
V jednu chvíli může nastat pouze jedna událost.
Indikátory jsou aktualizovány pomocí metody \texttt{update\_indicators}.
Vstupní a výstupní hodnoty lze získat voláním getrů třídy.
Lze je použít pro vykreslování grafů.

\subsection{Indikátor}
Indikátor může být typu \texttt{sma} nebo \texttt{ema}.
Běžným způsobem, jak umožnit oba typy, by bylo použití runtime polymorfismu prostřednictvím virtuálních funkcí.
Oba indikátory by musely dědit ze společné třídy a implementovat její virtuální funkce.
Instance třídy by musela být inicializována na haldě namísto zásobníku a dalo by se k ní přistupovat pomocí ukazatele na společnou třídu.
Jak dynamická alokace, tak použití virtuálních funkcí způsobují režii navíc.
Existuje několik nedávných přednášek z \textit{C++ konference} (CppCon) \cite{gobel-virtual, bogosavljevic-virtual}, které jsou zaměřeny na způsoby, jak se vyhnout používání virtuálních funkcí.
V obou přednáškách jsou zapojeny prvky moderního C++.

Jako nejvhodnější se v tomto případě nabízí použití třídy \texttt{std::variant} zavedené standardem C++17.
Třída funguje jako uložiště pro různé typy.
Pro uložení instance daného typu používá staticky alokované pole bajtů, který má velikost největšího uložitelného typu.
Jako třídní šablonové parametry přebírá seznam typů, které mohou být v objektu uloženy.
K hodnotě uložené v instanci objektu lze přistupovat pomocí funkce \texttt{std::get}.
Funkce přijímá šablonový argument, který je buď indexem typu, nebo samotným typem, který by měl být aktuálně v instanci uložen.
Pokud je uložen jiný typ, tak volání funkce způsobí vyhození \texttt{std::bad\_variant\_access} výjimky.

Dalším způsobem přístupu k uložené hodnotě je použití funkce \texttt{std::visit}.
Vyžaduje 2 argumenty, první je volatelný objekt a druhý instance třídy \texttt{std::variant}.
Funkce při volání nejprve získá hodnotu uloženou v instanci a poté ji předá volatelnému objektu.
V případě indikátorů může být použita například při jeho aktualizaci (viz \ref{lst:update:indicator}).

\begin{lstlisting}[caption={~Aktualizace indikátoru pomocí std::visit},label={lst:update:indicator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
std::variant<sma, ema> ma{sma{30}};
bool ready = std::visit([&value](auto& indic) {
    return indic.update(value);
}, ma);
\end{lstlisting}

Aby bylo možné objekt zapouzdřit a snadněji spravovat, byla vytvořena třída \texttt{bazooka::indicator}.
Třída má pouze jeden členský atribut \texttt{data\_} typu \texttt{std::variant<sma, ema>}, který je používán pro uložení indikátoru.
Metody používají \texttt{std::visit} pro přístup a změnu hodnoty indikátoru.
Sdílí stejné rozhraní s třídami \texttt{sma} a \texttt{ema}.

\subsubsection{Indikátory založené na klouzavém průměru}
Byly implementovány dva indikátory založené na klouzavém průměru \texttt{sma} a \texttt{ema}.
Sdílejí stejné rozhraní.
Jsou aktualizovány voláním metody \texttt{update} a jejich hodnotu lze získat voláním metody \texttt{value}.
Metoda \texttt{update} vrací hodnotu boolean indikující, zda je indikátor připraven.
Lze to také zkontrolovat voláním metody \texttt{is\_ready}.

Počáteční hodnota indikátoru \texttt{ema} je získána pomocí indikátoru \texttt{sma} se stejnou periodou.
Další hodnoty se vypočítají pomocí vzorce, který používá aktuální hodnotu.
Třída \texttt{sma} používá \texttt{boost::circular\_buffer} k uložení předchozích hodnot pro výpočet průměru.
Jakmile je buffer plný, tak je indikátor připraven.

\subsection{Manažer}
Účelem manažera je realizovat akce vytvořené strategií.
Je implementován pomocí třídy \texttt{bazooka::manager}.
Komunikuje s burzou a zabývá se tvorbou objednávek a řízením rizik.
Dvě nejdůležitější metody pro vytváření objednávek jsou \texttt{create\_open\_order} a \texttt{create\_close\_all\_order}.
Objednávky jsou reprezentovány strukturou \texttt{order}, která obsahuje 3 atributy: prodané množství, cenu, za kterou bylo aktivum nakoupeno/prodáno, a čas jejího vytvoření.

Strategie používá $n$ nákupních úrovní.
Vždy začíná obchodovat s počátečním zůstatkem, který je rozdělen na $n$ velikostí nákupu.
Skutečné velikosti objednávek lze vypočítat buď na začátku, nebo průběžně.
Výpočet velikostí objednávek za běhu se zdálo být přirozenější, takže byla implementována třída \texttt{order\_sizer}.
Při konstrukci přijímá pole velikostí objednávek $s$ a převádí jej na pole akumulovaných velikostí $a$, kde platí, že $s_0 = a_0 \land a_n = 1 \land [\forall i \in \{0,\dots,n\} : a_i = \sum_{j=0}^{i} s_j]$.
Po zavolání instance je vynásoben zůstatek aktuální akumulovanou velikostí pro získání velikosti objednávky.

Vzhledem k tomu, že má manažer přístup k burze, tak poskytuje metody pro přístup k jejímu aktuálnímu stavu, jako je zůstatek peněženky, čistá hodnotu a aktuální zisk aktivní pozice.
Jakmile je objednávka provedena, je uložena jako poslední otevřená/uzavřená objednávka a lze k ni přistupovat prostřednictvím getrů třídy.
Je to cenná informace pro vykreslování grafů a výpočet statistik.
Může nebo nemusí být použita, takže je lepší ji uložit samostatně a neustále ji přepisovat, než všechny ukládat například do instance \texttt{std::vector}, což by způsobilo zbytečnou režii navíc.

\section{Obchodník}
Funkcionality tříd \texttt{bazooka::manager} a \texttt{bazooka::strategy} jsou propojeny pomocí \texttt{bazooka::trader}.
Pro zpřístupnění veřejných metod obou tříd je použita vícenásobní veřejná dědičnost.
Třída poskytuje metodu \texttt{trade} \ref{lst:trade}, která používá metody obou tříd.
Strategie činí rozhodnutí, která manažer uskutečňuje.
Metoda vrací výčet \texttt{action} udávající, která akce byla provedena.

\begin{lstlisting}[caption={~Implementace metody trade třídy \texttt{bazooka::trader}},label={lst:trade},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
action trade(const price_point& curr)
{
    action done{action::none};
    if (!Strategy::is_ready()) return done;

    if (Strategy::should_open(curr.data)) {
        Manager::create_open_order(curr);
        done = action::opened;
    }
    else if (Strategy::should_close_all(curr.data)) {
        Manager::create_close_all_order(curr);
        done = action::closed_all;
    }
    return done;
}
\end{lstlisting}

\section{Burza}
Burza je implementována pomocí třídy \texttt{market}.
Ve srovnání se skutečnou burzou je to velmi zjednodušená.
Podporuje pouze objednávky typu long a jeden uživatelský účet.
Mezi třídní atributy patří: aktivní pozice, poslední uzavřená pozice, peněženka a výše poplatků spojených s realizací objednávek.

Peněženka je implementována třídou \texttt{wallet} a slouží ke správě zůstatku zákaznického účtu.
Zůstatek lze snížit voláním metody \texttt{withdraw} nebo navýšit použitím \texttt{deposit}.
Pokud je částka k výběru větší než aktuální zůstatek, tak je vyhozena výjimka \texttt{insufficient\_funds}.
Aktivní pozice je uložena v instanci \texttt{std::optional}, jelikož pozice nemusí být otevřena.

Pomocí metody \texttt{fill\_open\_order} může být aktivní pozice otevřena nebo navýšena v závislosti na tom, zda již existuje.
Po otevření lze pozici uzavřít jako celek pomocí \texttt{fill\_close\_all\_order} metody, nikoli po částech.
Třída také poskytuje getry pro získání přístupu k aktuální čísté hodnotě, kontrolu, zda je otevřená pozice, nebo zjištění aktuálního zisku aktivní pozice.

\section{Pozice}
Pozice je implementována třídou \texttt{position}.
Lze ji otevřít vytvořením instance třídy, zvýšit voláním metody \texttt{increase} nebo uzavřít pomocí metody \texttt{close}.
Celkové množství nakoupeného aktiva lze zjistit voláním metody \texttt{size}.
Dále lze získat aktuální hodnotu a aktuální zisk.
Vzhledem k tomu, že je v průběhu ukládán celkový realizovaný zisk a celková investovaná částka, tak je lze zjistit i po uzavření pozice.
Při změně velikosti pozice jsou uplatňovány poplatky.
Výše otevíracích a uzavíracích poplatků jsou poskytnuty při inicializaci.

\section{Simulátor}
Obchodování lze simulovat pomocí třídy \texttt{simulator}, která uchovává a připravuje historická data pro simulaci a umožňuje její provedení.
Hlavním účelem třídy je použít ji jako objektivní funkci během optimalizace.
Obchodování lze pozorovat pomocí pozorovatelů.
Tímto způsobem lze například použít třídu \texttt{bazooka::statistics::collector} ke sběru statistik nebo ke sběru časových řad třídu \texttt{chart\_series::collector}, které mouhou být použity pro vykreslování grafů.

Při inicializaci jsou předány simulátoru historické ceny v podobě minutových svíček.
Pro rozhodování se používají minutové uzavírací ceny.
Ceny používané pro aktualizaci indikátorů jsou získány tak, že jsou minutové svíčky nejprve převzorkovány pomocí \texttt{resampler} na požadované časové období a zprůměrovány pomocí zvolené průměrovací metody.
Pokud je například doba převzorkování 30 minut a metoda průměrování \textit{OHLC4}, tak jsou svíčky nejprve převzorkovány na 30minutové svíčky a poté zprůměrovány pomocí \texttt{candle::ohlc4}.

Proces převzorkování probíhá tak, že za dané období se otevírací cena první svíčky stane otevírací cenou převzorkované svíčky a uzavírací cena poslední svíčky se stane její uzavírací cenou.
Vysoká a nízká cena jsou nejvyšší a nejnižší ceny v daném období.
Jelikož je převzorkování poměrně časově náročné, tak se provádí pouze jednou v konstruktoru, takže se neopakuje při každém volání simulátoru.

Simulátor při volání přebírá instanci obchodníka a seznam pozorovatelů \ref{lst:simulator}.
Iteruje přes rozhodovací ceny až do konce nebo dosažení minimální čisté hodnoty.
Pozorovatelé jsou během optimalizace informováni o událostech, jako je otevření pozice nebo aktualizace indikátoru.
Ceny použité pro aktualizaci indikátoru jsou procházeny pomocí iterátoru.

\begin{lstlisting}[caption={~Implementace simulace obchodování},label={lst:simulator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class Trader, class... Observer>
void operator()(Trader&& trader, Observer& ... observers)
{
    auto indic_prices_it = indic_prices_.begin();

    (observers.begin(trader, prices_.front()), ...);
    for (std::size_t i{0}; i<prices_.size() &&
        trader.equity(prices_[i].data)>min_equity_; i++) {
        (observers.traded(trader,trader.trade(prices_[i]),prices_[i]),...);

        if (trader.has_active_position())
            (observers.position_active(trader, prices_[i]), ...);

        // update indicators
        if (i && (i+1)%resampling_period_==0)
            if (trader.update_indicators((*indic_prices_it++)))
                (observers.indicators_updated(trader, prices_[i]), ...);
    }
    (observers.end(trader, prices_.back()), ...);
}
\end{lstlisting}

\section{Statistiky}
Nezbytnou součástí optimalizace jsou statistiky, jelikož jsou použity k formulaci optimalizačního kritéria a omezujících podmínek.
Statistiky, které jsou společné pro všechny obchodní strategie, jsou reprezentovány třídou \texttt{statistics} a jsou rozšířeny pro \textit{Bazooka} obchodovací strategii \texttt{bazooka::statistics}.

Instance třídy je inicializována předáním počátečního zůstatku.
Statistiky jsou aktualizovány pomocí metod pro aktualizaci \texttt{update\_equity()} nebo setrů \texttt{set\_final\_balance}.
K uloženým statistikám lze přistovat pomocí getrů.
Některé hodnoty, jako je celkový zisk, lze získat buď jako částku nebo v procentech.
Pro upřesnění jednotky a se používá značka \texttt{percent} nebo \texttt{amount} \ref{lst:use:unit:tag} při volání metody.

\begin{lstlisting}[caption={~Metody pro získání celkového zisku v různých jednotkách},label={lst:use:unit:tag},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class T>
requires std::same_as<T, amount>
amount_t total_profit() const
{
    return final_balance_-init_balance_;
}

template<class T>
requires std::same_as<T, percent>
percent_t total_profit() const
{
    return ((final_balance_-init_balance_)/init_balance_)*100;
}
\end{lstlisting}

Všechny statistiky související se ziskem jsou sledovány pomocí instance \texttt{profit\_statistics}, které lze použít k získání hrubého zisku, hrubé ztráty nebo faktoru zisku.
Dále jsou sledovány statistiky související s pohybem pomocí \texttt{motion\_statistics}, které poskytují minimální a maximální hodnotu, maximální vzestupný a sestupný pohyb.
Vzestupný pohyb je sledován pomocí \texttt{run\_up\_tracker} a sestupný pomocí \texttt{drawdown\_tracker}.
Tím to způsobem jsou sledovány čistá hodnota a uzavírací zůstatek.
Hodnoty lze opět vyjádřit v procentech nebo částkách.

Do třídy \texttt{bazooka::statistics} byl přidán čítač otevíracích objednávek pro jednotlivé nákupní úrovně.
Nese informace o tom, kolikrát bylo dosaženo jednotlivých úrovní nákupu, a může tak pomoci lépe porozumět tomu, jak se strategie chová.

\chapter{Další}
\section{Čtení a zápis do souborů}
Byly vytvořeny vlastní třídy pro čtení a zápis do souborů \textit{CSV}.
Jsou užitečné při čtení historických svíčkových dat a při ukládání časových řad pro vykreslování grafů.
Pro uložení nastavení a výsledků experimentu byl zvolen formát \textit{JSON} (\textit{JavaScript Object Notation}), který je standardizovaný a čitelný.
V tomto případě nebylo nutné vytvářet vlastní implementaci, protože existuje dobře známá, používaná a udržovaná knihovna \texttt{nlohmann/json} \cite{lohmann}.

% popsat JSON a vlatsní třídy

\subsection{Formát CSV}
Pro čtení a zápis do souborů \textit{CSV} (\textit{Comma-Separated Values}) byly vytvořeny třídy \texttt{csv::reader} a \texttt{csv::writer}.
Hodnoty jsou uloženy v tabulce, kde sloupce jsou hodnoty stejného typu odděleny oddělovačem, obvykle čárkou.
První řádek může obsahovat názvy sloupců, ale nemusí.

Obě třídy mají jeden třídní šablonový udávající počet sloupců.
Při inicializaci přebírají jako parametr cestu k souboru uloženému v instanci \texttt{std::filesystem::path} a oddělovač.
Soubor je otevřen při konstrukci třídy, pokud jej nelze otevřít, je vyhozena výjimka \texttt{std::runtime\_error}.
Soubor je uzavřen při destrukci objektu.

Třída \texttt{csv::reader} nabízí dvě metody pro čtení řádků: \texttt{read\_header} a \texttt{read\_row}.
Je přirozenější číst názvy sloupců do instance \texttt{std::array} než přímo do proměnných.
Čtení přímo do proměnných je dosaženo použitím sady šablonových parametrů \ref{lst:csv:read:row}.
Třída vrací booleovský příznak s informací o tom, zda byl řádek přečten nebo ne.
Hodnoty pak lze snadno číst v cyklu \texttt{while} (viz \ref{lst:read:candles}).
Třída \texttt{io::parser} je používána k parsování jednotlivých hodnot.

\begin{lstlisting}[caption={~Implementace čtení řádky třídy \texttt{io::csv::reader}},label={lst:csv:read:row},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class ...Types>
bool read_row(Types& ...inputs)
{
    static_assert(sizeof...(Types)==n_cols);
    if (!std::getline(file_, line_))
        return false;

    line_.erase(std::remove(line_.begin(),line_.end(),'\r'),line_.end());
    std::stringstream ss(line_);
    ss.exceptions(std::ios::failbit);

    auto parse_line = [&](auto& in) {
        read_value(ss, in);
    };

    (parse_line(inputs), ...);
    return true;
}
\end{lstlisting}

Třída \texttt{csv::reader} je používána velice podobně.
Má metodu pro zápis sloupců \texttt{write\_header} a pro zápis hodnot \texttt{write\_row}.
K převodu hodnot na textové řetězce používá třídu \texttt{io::stringifier}.

\begin{lstlisting}[caption={~Ukázka čtení svíček pomocí \texttt{io::csv::reader}},label={lst:read:candles},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
io::csv::reader<5> reader{path, sep};
std::time_t opened;
price_t open, high, low, close;
std::vector<candle> candles;

while (reader.read_row(opened, open, high, low, close))
    candles.emplace_back(candle{opened, open, high, low, close});
\end{lstlisting}

\subsection{Formát JSON}
Samotný formát se skládá ze dvou struktur: kolekce párů klíč-hodnota a pole.
Je založen na programovacím jazyce \textit{JavaScript}, ale protože je postaven ze základních datových struktur, je implementován v mnoha programovacích jazycích \cite{json}.

Pro \texttt{C++} je k dispozici několik \textit{JSON} knihoven, ale zdá se, že \texttt{nlohmann/json} mezi nimi vyniká nejvíc.
Na příslušné \textit{GitHub} stránce je uvedeno, že jde o knihovnu \textit{JSON} pro moderní \textit{C++}, má 34 tisíc hvězdiček, je důkladně testována a pečlivě zdokumentována \cite{lohmann}.

Podporuje vytvoření specifikace pro serializaci a deserializaci vlastních typů.
Pro daný typ je vytvořena specializace struktury \texttt{adl\_serializer}, která může mít dvě metody \texttt{from\_json} pro deserializaci a \texttt{to\_json} pro serializaci.
Implementaci pro třídu \texttt{bazooka::indicator} lze vidět ve výpise \ref{lst:json:serialize}.

\begin{lstlisting}[caption={~Implementace deserializace pro vlastní datový typ},label={lst:json:serialize},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<>
struct adl_serializer<trading::bazooka::indicator> {
    static void to_json(json& j, const bazooka::indicator& indic)
    {
        j = {{"period", indic.period()},
             {"name",   indic.name()}};
    }
};
\end{lstlisting}

\section{Shromažďování výsledků}

\subsection{Enumerační výsledek}
Třída \texttt{enumeration\_result} slouží ke shromažďování $n$ nejlepších výsledků.
Má 2 třídní šablonové parametry: typ výsledku a funkci pro jejich porovnávání.
Interně používá datovou strukturu \textit{halda}, jelikož má složitost $\mathcal{O}(log{}n)$ pro vložení nového prvku a odstranění prvního.
K ukládání výsledků používá kontejner \texttt{std::vector}.
Hodnoty jsou aktualizovány voláním metody \texttt{update}.
K vytvoření haldy používá funkci \texttt{std::push\_heap} a jakmile je plná, použije po vložení nového prvku funkci \texttt{std::pop\_back} k odstranění nejhoršího prvku \cite{push-heap}.
K získání výsledku lze zavolat metodu \texttt{get}, která používá funkci \texttt{std::sort\_heap} k seřazení prvků v požadovaném pořadí.

\chapter{Optimalizace}

\section{Návrh a generování stavového prostoru}
Pro optimalizaci byly vybrány 4 konfigurační proměnné: typ indikátoru, perioda indikátoru, úrovně a velikosti nákupů.
Hodnoty proměnných lze generovat buď systematicky, nebo náhodně.
Důležitým aspektem, který bylo nutné dodržet, bylo, že obě verze generátorů musí generovat hodnoty ze stejného vyhledávacího prostoru, jinak by byly výsledky jednotlivých optimalizačních metod nesrovnatelné.

Generátory sdílejí společné rozhraní, jakmile jsou vytvořeny, lze je použít voláním volacího operátoru třídy.
Náhodné generátory mají volací operátor přetížen.
Specializace přebírá argument představující původní hodnotu, která je používaná při generování následující.
Generátory vracejí přímo datové typy představující konfigurační proměnné.
V ideálním případě by měly generovat stejné hodnoty se stejnou pravděpodobností.

Systematické generátory vracejí stejné hodnoty pouze jednou.
Nevrací hodnotu přímo, ale místo toho vrací korutinu.
Byly představeny ve standardu \texttt{C++20}.
Při volání funkce umožňují její provádění pozastavit a později obnovit \cite{coroutines}.
Existuje knihovna \textit{CppCoro}, která poskytuje implementace generátorů \texttt{cppcoro::generator} a \texttt{cppcoro::recursive\_generator} \cite{cppcoro}.


\subsection{Typ indikátoru}
Typ indikátoru je reprezentován enumerační třídou \texttt{indicator\_tag} se dvěma možnými hodnotami: \texttt{indicator\_tag::ema} a \texttt{indicator\_tag::sma}.
Jediný způsob, jak parametrizovat tuto proměnnou, je použít buď jednu z hodnot, nebo obě.
Hodnoty jsou stejného typu, takže je lze uložit do pole.
Jelikož je jeho velikost malá a maximální velikost je známa v době kompilace, tak lze použít \texttt{etl::vector} k uložení hodnot pro generování.
Hodnoty lze náhodně rovnoměrně generovat pomocí instance třídy \tttext{std::uniform\_int\_distribution}.

\subsection{Perioda indikátoru}
SMA i EMA mají parametr perioda $p>1$.
Oba generátory generují hodnoty v intervalu $[f, t]$ s krokem $s$, kde $((f>t\implies((f-t) \mod s)=0 \land s<0) \land (t<f\implies((t-f) \mod s)=0 \land s>0)) \land s\neq0 \land t\neq f$.
Počet možných výstupních hodnot je roven $n=\frac{|t-f|}{s}+1$.
Pro systematické generování period byl použit generátor \texttt{systematic::int\_range}.

\subsubsection{Náhodné generování}
Při generování bez počáteční periody je nejprve pomocí \tttext{std::uniform\_int\_distribution} vygenerována hodnota $ v \in [\frac{p_{min}}{s}, = \frac{p_{max}}{s}$], kde $p_{min}=min(f, t) \land p_{max}=max(f, t)$, která je následně přeškálována $p_o=v\cdot s \land p_o \in [p_{min}, p_{max}]$.

Při generování hodnoty z počátku $o$ používá generátor navíc parametr $k\in[1,n/2]$.
Například, když $f=1$, $t=5$, $s=1$, $o=3$ a $k=1$, pak jsou všechny možné výstupní hodnoty periody $ p_o \in [o-(k\cdot s), o+(k\cdot s)]=[2, 4]$.

Na okrajích intervalu, kdy mohou být hodnoty generovány z 2 podintervalů. Například, když $f=1$, $t=5$, $s=1$ a $k=1$, pak jsou všechny možné výstupní periody $p_o \in [1, 2] \cup [5, 5]$.
Jelikož jsou periody generovány pomocí datového typu integer, který může nabývat i záporných hodnot, lze nejprve vygenerovat hodnotu $ w \in [o-(k\cdot s), o+(k\cdot s)]$, výslednou periodu získat $(w<p_{min}\implies(p_o=w+(n*|s|))) \land (w>p_{max}\implies(p_o=w-(n*|s|))) \land (w \in [p_{min}, p_{max}]\implies p_o=w)$.

\subsection{Úrovně nákupu}
Pro úrovně nákupu platí, že $\{l_0, l_1,\dots,l_n\} \in \mathbb{Q} \cap [0, 1] \land n>0 \land [\forall i \in \{0,\dots,n-1\} : l_i > l_{i+1}]$.
Příkladem takové sekvence racionálních čísel může být $\{\frac{1}{2}, \frac{1}{3}, \frac{1}{4}\}$.
Generátory jsou parametrizovány pomocí parametru $u\geq n$, který označuje počet jedinečných zlomků, které se mohou v sekvenci objevit.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=u+1$.
Pro $n=3$, $u=4$ jsou všechny možné platné sekvence: $\{\frac{4}{5}, \frac{3}{5}, \frac{2}{5}\}, \{\frac{4}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{4}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{2}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Sekvence jsou generovány rekurzivně (viz \ref{lst:systematic:levels_generator}), protože se počet smyček \texttt{for} liší v závislosti na velikosti sekvence $n$.
Smyčky jsou na sobě závislé, následující (hlubší) smyčka musí znát předchozí hodnotu čitatele.
Nejvnitřnější smyčka vrací výslednou sekvenci.

\begin{lstlisting}[caption={~Metody pro systematické generování úrovní nákupu},label={lst:systematic:levels_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_levels>
    requires (depth==n_levels)
    value_type generate(std::size_t) { co_yield this->levels_; }
    
    template<std::size_t depth = 0>
    requires (depth<n_levels)
    value_type generate(std::size_t prev_num)
    {
        for (std::size_t num{--prev_num}; num>n_levels-depth-1; num--) {
            this->levels_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}
Instance třídy \texttt{trading::random::levels\_generator} má mezi svými atributy pole se všemi možnými hodnotami výstupní sekvence.
Při generování náhodné sekvence bez počátku nejprve tyto hodnoty zamíchá, seřadí prvních $n$ prvků v sestupném pořadí a nakonec je zkopíruje do výstupního pole.

Náhodné generování na základě počáteční sekvence je složitější.
Používá parametr $k \in [1, n] $, který je předán instanci při její konstrukci.
Udává počet prvků počáteční sekvence, které by měly být změněny.
Při generování je nejprve náhodně vybráno $n-k$ prvků, které budou zachovány z původní sekvence, a jsou uloženy do instance \texttt{etl::flat\_set}, což je kontejner pevné velikosti, který ukládá jedinečné prvky v určeném pořadí.
Dále je zamícháno pole se všemi možnými hodnotami.
Ve smyčce \texttt{while} jsou hodnoty vkládány do setu až do jeho naplnění.
Nakonec jsou hodnoty překopírovány ze setu do výstupního pole.

\subsection{Velikosti nákupu}
Pro velikosti nákupu platí, že $ (\-s_0, s_1,\dots,s_n)\ \in \mathbb{Q} \cap [0, 1] \land n>1 \land \sum_{i=0}^{n} s_i = 1 $.
Příkladem takové sekvence může být $ (\frac{1}{4}, \frac{2}{4}, \frac{1}{4})\ $.
Generátory jsou parametrizovány pomocí parametru $u\geq 1$, který označuje počet jedinečných zlomků, které se mohou v sekvenci objevit.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=n+u-1$.
Pro $n=3$, $u=3$ jsou všechny možné platné sekvence: $\{\frac{1}{5}, \frac{1}{5}, \frac{3}{5}\}, \{\frac{1}{5}, \frac{2}{5}, \frac{2}{5}\}, \{\frac{1}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{2}{5}, \frac{1}{5}, \frac{2}{5}\}, \{\frac{2}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{1}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Velikosti nákupů \ref{lst:systematic:sizes_generator} jsou systematicky generovány podobně jako úrovně nákupů.
Používá se také rekurze, každá smyčka \texttt{for} předává součet zbývajících čitatelů následující smyčce.
Maximální lokální čitatel má buď hodnotu globálního maximálního čitatele, nebo součet zbývajících čitatelů snížený o jedna.

\begin{lstlisting}[caption={~Metody pro systematické generování velikostí nákupu},label={lst:systematic:sizes_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_sizes>
    requires (depth+1==n_sizes)
    value_type generate(std::size_t remaining)
    {
        this->sizes_[depth] = fraction_t{remaining, this->denom_};
        co_yield this->sizes_;
    }

    template<std::size_t depth = 0>
    requires (depth+1<n_sizes)
    value_type generate(std::size_t remaining)
    {
        std::size_t max = (remaining>this->max_num_)
            ? this->max_num_ : remaining-1;
        for (std::size_t num{1}; num<=max; num++) {
            this->sizes_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(remaining-num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}

\section{Optimalizátory}
Při vytváření optimalizátorů byly brány v úvahu 2 hlavní cíle: za prvé, aby byly co nejobecnější a za druhé, aby bylo možné snadno sledovat a později analyzovaly průběh optimalizace.
Samotné optimalizátory mají pouze několik atributů, které by měly být společné pro všechny možné problémy, které lze optimalizovat.
Další části algoritmu jsou dodány při samotném volání algoritmu.

Komponenty, které jsou předány při volání optimalizátoru, jsou reprezentovány jako koncepty namísto běžných šablon.
Do \textit{C++} byly koncepty přidány ve standardu \texttt{C++20} a slouží ke specifikovaným požadavkům na argumenty šablony \cite{concepts}.
U volatelných argumentů lze například pomocí konceptů definovat typy vstupních a výstupních argumentů.
Ukázku použití konceptů pro definování algoritmu chlazení pro třídu \texttt{optimizer::simulated\_annealing} lze vidět ve výpise \ref{lst:cooling:concept}.
Chyby generované kompilátorem při použití objektu se špatným rozhraním jsou často čitelnější a přímější při použití konceptů než samotných šablon.

\begin{lstlisting}[caption={~Koncept pro kontrolu chladícího algoritmu},label={lst:cooling:concept},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class ConcreteCooler, class SimulatedAnnealing>
concept Cooler = std::invocable<ConcreteCooler, SimulatedAnnealing&> &&
std::same_as<void,std::invoke_result_t<ConcreteCooler,SimulatedAnnealing&>>;
\end{lstlisting}


Ke sledování průběhu heuristických optimalizací jsou požívány objekty typu pozorovatel.
Pozorovatelé jsou upozorňovány na události, ke kterým dochází během optimalizace.
Průběh optimalizace mohou hlásit nebo ukládat.
Příkladem události, která může nastat během optimalizace simulovaného ochlazování, je snížení teploty nebo přijetí lepšího stavu.
Pozorovatelé jsou předány jako poslední parametr při volání optimalizátoru a jsou uloženy jako sada parametrů šablony.
Tímto způsobem lze přijmout víc než jeden pozorovatel nebo žádný.

\subsection{Hrubá síla}
Algoritmus je implementován třídou \texttt{brute\_force::parallel::optimizer}.
Prochází všechny stavy prohledávacího prostoru a zajišťuje nalezení optimálního řešení.
Je vhodný pro relativně malé vyhledávací prostory a může pomoci lépe porozumět vlastnostem cenové funkce.

Vyhledávací prostor je generován pomocí systematických generátorů, které jsou volány ve vnořených smyčkách \texttt{for} (viz \ref{lst:systematic:states_generator}).
Nejvnitřnější cyklus vrací konfiguraci jako korutinu typu \texttt{cppcoro::generator}.
Vytvoření vyhledávacího prostoru tímto způsobem je jednodušší než navrhování vlastního iterátoru, jelikož na sobě mohou být jednotlivého hodnoty závislé.

\begin{lstlisting}[caption={~Ukázka generování systematického stavového prostoru},label={lst:systematic:states_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
auto search_space = [&]() -> cppcoro::generator<config_type> {
    for (std::size_t period: periods_gen())
        for (const auto& tag: tags)
            for (const auto& levels: levels_gen())
                for (const auto& open_sizes: sizes_gen())
                    co_yield config_type{tag, period, levels, open_sizes};
};
\end{lstlisting}

Vzhledem k tomu, že jsou jednotlivé stavy na sobě nezávislé, může být vyhledávání paralyzováno.
Paralelizace byla implementována pomocí direktiv z knihovny \textit{OpenMP}.
Jelikož je vyhledávací prostor předáván jako korutina, lze jej paralelizovat pouze pomocí taskového paralelismu použitím direktivy \texttt{task}.

Implementaci paralelizace lze vidět ve výpise \ref{lst:brute-force}.
Nejprve je použita direktiva \texttt{parallel} k vytvoření paralelního regionu, který vytváří, provádí a ukončuje jednotlivá vlákna.
Následně je pomocí direktivy \texttt{single} proveden cyklus \texttt{for} právě jedním vláknem.
Uvnitř cyklu jsou vytvářeny jednotlivé úlohy pomocí direktivy \texttt{task} a prováděny paralelně jednotlivými vlákny.
Každé vlákno nejprve zavolá cenovou funkci k získání ceny.
Vytvoří stav skládající se z konfigurace a ceny.
Pokud stav splňuje omezující podmínky, je v kritické sekci aktualizován výsledek.
Je nutné použít synchronizaci, protože může být výsledek modifikován více vlákny najednou.

\begin{lstlisting}[caption={~Optimalizace pomocí algoritmu hrubé síly},label={lst:brute-force},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
#pragma omp parallel
{
    #pragma omp single
    {
        for (const auto& config: search_space()) {
            #pragma omp task
            {
                auto curr_state = state{config, cost(config)};
                if (constrains(curr_state)) {
                    #pragma omp critical
                    result.update(curr_state);
                }}}}}
\end{lstlisting}

\subsection{Simulované ochlazování}
Algoritmus simulovaného ochlazování je implementován třídou \texttt{simulated\_annealing::optimizer}.
Třída má pouze několik členských atributů: současnou, počáteční a minimální teplotu, počet iterací a současný stav.
Jiné části algoritmu jako chlazení, ohodnocení horšího stavu a nalezení sousedního stavu jsou specifické pro řešený problém, proto jsou předány jako argumenty při volání instance objektu.

Bylo implementováno několik chladicích algoritmů vycházejících ze srovnávajícího článku \cite{cooling-comparison}.
Všechny jsou umístěny v souboru \texttt{simulated\_annealing/cooler.hpp}.
Většina je parametrizována parametrem decay, který se používá k řízení rychlosti snižování teploty.
Správnost jeho hodnoty závisí na algoritmu chlazení a ověřuje se při inicializaci konkrétního objektu.

Chladiče používají návrhový vzor \textit{Strategy}, který funguje následovně, namísto předávání seznamu argumentů při volání chladiče je jako argument předán samotný optimalizátor.
Algoritmus chlazení si tak může sám zvolit, které atributy heuristiky použije k výpočtu následující teploty a změnit její hodnotu může pomocí setteru třídy.
Příklad implementace chladiče lze vidět na \ref{lst:cooling}.

\begin{lstlisting}[caption={~Ukázka implementace chlazení třídy \texttt{simulated\_annealing::exp\_mul\_cooler }},label={lst:cooling},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
void operator()(SimulatedAnnealing& optimizer)
{
    optimizer.current_temperature(optimizer.start_temperature()*
        std::pow(this->decay_, optimizer.it()));
}
\end{lstlisting}

Algoritmus pro nalezení náhodného souseda je implementován pomocí třídy \texttt{bazooka::neighbor}.
Ke generování sousední konfigurace využívá náhodné generátory, které na základě aktuální hodnoty generují následující hodnotu.
Náhodně je vždy změněn pouze jeden konfigurační parametr.
Pro realizaci \textit{equilibria} byl implementován algoritmus založený na pevném počtu prohledávaných sousedních stavů \texttt{simulated\_annealing::fixed\_iteration\_equilibrium}.

Implementaci algoritmu lze vidět ve výpisu \ref{lst:simulated:annealing}.
Během optimalizace dochází k několika událostem, které jsou hlášeny pozorovatelům.
Pro sběr dat o průběhu optimalizace byla implementována třída \texttt{simulated\_annealing::progress\_collector}.
Za účelem logování byla vytvořena třída \texttt{simulated\_annealing::progress\_reporter}.

\begin{lstlisting}[caption={~Implementace simulovaného ochlazování},label={lst:simulated:annealing},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
curr_state_ = state{init_config, objective(init_config)};
(observers.begin(*this), ...);

for (; curr_temp_>min_temp_; it_++) {
    while (equilibrium()) {
        Config config = neighbor(curr_state_.config);
        auto candidate = state{config, objective(config)};

        if (result.compare(candidate, curr_state_)) {
            curr_state_ = candidate;
            (observers.better_accepted(*this), ...);

            if (constraints(curr_state_))
                result.update(curr_state_);
        }
        else {
            double diff = appraiser(curr_state_, candidate);
            double threshold = std::exp(-diff/curr_temp_);

            if (rand_prob_gen_()<threshold) {
                curr_state_ = candidate;
                (observers.worse_accepted(*this, threshold), ...);
            }
        }
    }
    cooler(*this);
    (observers.cooled(*this), ...);
}
(observers.end(*this), ...);
\end{lstlisting}

\subsection{Genetický algoritmus}
Genetický algoritmus je implementován třídou \texttt{genetic\_algorithm::optimizer}.
Má pouze 2 třídní atributy, počet iterací a populaci.
Další části algoritmu jsou poskytovány při jeho volání.
Populace je uložena pomocí třídy \texttt{std::vector}, která spravuje dynamicky alokované pole prvků.
Bylo dbáno na to, aby došlo k co nejmenšímu počtu realokací v průběhu optimalizace, a to opětovným použitím již alokovaného pole pomocí metody \texttt{clear} a použití metody \texttt{reserve}, kdykoli je dopředu známa velikost pole.
Jinak by docházelo ke zbytečnému zpomalování optimalizace.

Pro mutaci lze použít instanci třídy \texttt{bazooka::neighbor}.
Algoritmus pro křížení je implementován třídou \texttt{bazooka::crossover}.
Při křížení se používají všechny konfigurační proměnné, a proto je pro každou z nich implementován operátor křížení.
O tom, zda potomek obdrží periodu indikátoru nebo typ indikátoru od své matky nebo otce, se rozhoduje hodem mincí.
Pro křížení úrovní a velikostí nákupů byly vytvořeny vlastní třídy.

Křížení úrovní nákupu je implementováno třídou \texttt{bazooka::levels\_crossover}.
Funguje tak, že genetickou informaci od otce a matky vloží do společného pole typu \texttt{etl::vector}, které na rozdíl od \texttt{std::vector} používá statickou alokaci místo dynamické.
Geny jsou náhodně zamíchány a následně vkládány ve \texttt{while} cyklu do instance \texttt{elt::flat\_set} do jejího naplnění.
Hodnoty jsou nakonec překopírovány do výstupního pole.
Algoritmus má několik vlastností, jednou z nich je, že pokud jsou rodiče stejní, bude i potomek stejný.
Pokud mají rodiče společný gen, je větší šance, že bude vybrán.

Křížení velikostí nákupů je implementováno třídou \texttt{bazooka::sizes\_crossover}.
Nejmenší hodnoty rodičů jsou použity jako základ pro potomka.
Dále jsou nákupní velikosti dítěte náhodně zvyšovány v cyklu \texttt{while} tak, aby velikost nákupu nikdy nebyla větší než nejvyšší hodnota rodiče.
Smyčka končí, jakmile je součet všech velikostí roven 1.
Výsledné hodnoty potomků se tedy budou vždy pohybovat v rozmezí hodnot rodičů.
Pokud rodiče nejsou stejní, potomek je jiný, ale stále je podobný svým rodičům.

Pro výběr rodičů byl implementován ruletový výběr \texttt{genetic\_algorithm::roulette\_selection}.
Interně používá instanci třídy \texttt{std::discrete\_distribution} pro výběr rodičů.
Zdatnost každého jednotlivce představuje váhu, čím vyšší je váha, tím pravděpodobněji bude daný jedinec vybrán jako rodič.

Byl implementován \texttt{random\_matchmaker} algoritmus náhodného párování rodičů.
Rodiče jsou nejprve náhodně zamícháni a následně párováni.
Celkový počet rodičů nemusí být dělitelný počtem vybíraných n-tic, takže někteří rodiče mohou být použiti vícekrát.

Poslední část algoritmu se zabývá nahrazením původní generace za novou.
Byly implementovány 2 přístupy.
\textit{En block} nahrazování reprezentované třídou \texttt{en\_block\_replacement} zachovává pouze děti k vytvoření nové generace.
Druhý přístup používá \textit{elitismus} a je implementován třídou \texttt{elitism\_replacement}.
Třída má parametr $l\in[0, 1]$ představující zlomek vybraných elitních rodičů.
Nejprve seřadí rodiče podle zdatnosti a poté jimi nahradí prvních n dětí.
Implementaci algoritmu lze vidět ve výpise \ref{lst:genetic:algorithm}.
Data o průběhu optimalizace lze shromažďovat pomocí \texttt{progress\_collector} a zaznamenávat pomocí \texttt{progress\_reporter}.

\begin{lstlisting}[caption={~Implementace genetického algoritmu},label={lst:genetic:algorithm},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
population_.clear(), population_.reserve(init_genes.size());
for (const auto& genes: init_genes)
    population_.emplace_back(std::move(individual{genes,
        compute_fitness(genes)}));

std::vector<individual> parents, children;
(observers.begin(*this), ...);
for (; population_.size() && !termination(*this); it_++) {
    parents.clear();
    selection(sizer(population_.size()), population_, parents);

    // mate
    children.clear();
    for (const auto& mates: match(parents))
        for (auto&& genes: crossover(mates)) {
            genes = mutation(std::move(genes));
            auto child = individual{genes, compute_fitness(genes)};
            children.template emplace_back(std::move(child));
        }

    // replace
    population_.clear();
    replacement(parents, children, population_);
    (observers.population_updated(*this), ...);
};
(observers.end(*this), ...);
return population_;
\end{lstlisting}

\subsection{Tabu prohledávání}
Tabu prohledávání je implementováno třídou \texttt{tabu\_search::optimizer}.
Má 3 třídní atributy: počet iterací, aktuální a nejlepší stav.
Pro ukládání zakázaných tahů byla implementována třída \texttt{bazooka::moves\_memory}.
Ukládá pouze konfigurační atributy, které byly změněny, nikoli celé konfigurace.
Perioda a typ indikátoru jsou zapamatovány tak, jak jsou.
Hodnoty úrovně a velikosti nákupu, které nebyly změněny, se vynulují.
K ukládání úrovní a velikostí nákupu se používá \texttt{std::map}.

Jelikož existují 4 konfigurační proměnné, z nichž se vždy mění pouze jedna, tak se tah ukládá do instance třídy \texttt{std::variant}, která je zapouzdřena pomocí třídy \texttt{bazooka::movement}.
Vzhledem k tomu, že úrovně a velikosti nákupu jsou reprezentovány stejným datovým typem, polem zlomků, je nutné implementovat způsob, jak je rozlišit.
Třída proto obsahuje výčtovou třídu zvanou \texttt{indices}, ke které lze přistupovat zvenčí.
Lze ji použít ve výrazech \texttt{switch} \ref{lst:movement:usage}.
Tah lze uložit a zpřístupnit pomocí setrů a getrů.

\begin{lstlisting}[caption={~Použití třídy \texttt{bazooka::movement}},label={lst:movement:usage},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
bool contains(const move_type& move) const
{
    switch (move.indices()) {
    case move_type::indices::tag:
        return indic_mem_.contains(move.tag);
    case move_type::indices::period:
        return period_mem_.contains(move.period());
    case move_type::indices::levels:
        return levels_mem_.contains(move.levels());
    default:
        return sizes_mem_.contains(move.open_sizes());
    }
}
\end{lstlisting}

Hodnoty vložené do paměti v ní zůstávají po určitý počet iterací.
Při každé iteraci se počet iterací sníží pouze pro konfigurační parametr, který byl změněn.
Pevný počet operací lze nastavit pomocí instance třídy \texttt{tabu\_search::fixed\_tenure} pro paměť každého konfiguračního parametru.

Sousední konfigurace lze vygenerovat pomocí \texttt{bazooka::neighbor}, která vrací sousední konfiguraci včetně tahu.
Velikost sousedství říká, kolik sousedních konfigurací je prohledáno během jedné iterace.
Celý algoritmus lze vidět ve výpise \ref{lst:tabu:search}.

\begin{lstlisting}[caption={~Implementace genetického algoritmu},label={lst:tabu:search},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
best_ = curr_ = state{init, compute_fitness(init)};
state candidate, origin;
typename TabuList::move_type curr_move, candidate_move;

(observers.begin(*this), ...);
for (; !terminate(*this); it_++) {
    origin = curr_;
    std::tie(curr_.config, curr_move) = neighbor(origin.config);
    curr_.fitness = compute_fitness(curr_.config);

    for (std::size_t i{0}; i<neighborhood_size(*this)-1; i++) {
        std::tie(candidate.config,candidate_move)=neighbor(origin.config);

        if (!tabu_list.contains(candidate_move)) {
            candidate.fitness = compute_fitness(candidate.config);

            if (optim_criteria(candidate.fitness, curr_.fitness)
                || aspire(candidate, *this)) {
                curr_ = candidate;
                curr_move = candidate_move;
            }}}

    if (optim_criteria(curr_.fitness, best_.fitness))
        best_ = curr_;

    tabu_list.forget(curr_move);
    tabu_list.remember(curr_move.index());
    (observers.iteration_passed(*this, tabu_list), ...);
}
(observers.end(*this), ...);
\end{lstlisting}
