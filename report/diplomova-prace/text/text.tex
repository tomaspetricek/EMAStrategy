% Do not forget to include Introduction
%---------------------------------------------------------------
% \chapter{Introduction}
% uncomment the following line to create an unnumbered chapter
\chapter*{Introduction}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

Backtesting je nezbytnou součástí při vývoji obchodní strategie.
Ukazuje, jak by si strategie vedla, kdyby byla nasazena v minulosti.
Cílem je lépe pochopit fungování dané strategie, zjistit, kde jsou její úskalí a ideálně je opravit před nasazením do produkce.
Strategie jsou často parametrizované a při obchodování s různými aktivy mohou fungovat různé kombinace hodnot.
Pro maximalizaci ziskovosti strategie a snížení rizik je zapotřebí rychlý a spolehlivý způsob optimalizace těchto parametrů \cite{efficient-backtesting}.

Nejjednodušší a časově nejnáročnější způsob, jak najít optimální nastavení, by bylo prohledat všechny možné kombinace.
Největší výhodou tohoto přístupu je, že zaručuje nalezení nejlepšího možného řešení, nicméně je v praxi nepoužitelný pro velké množství možností, protože nedokončí v přiměřeně krátké době \cite{efficient-backtesting}.

\chapter{Design}

\subsection{Jmenné konvence}
Konvence pojmenování jsou převzaty z \textit{STL} a \textit{Boost} knihoven.
Názvy tříd a funkcí používají \texttt{snake\_case}.
Metody nastavení a čtení atributů třídy nepoužívají \texttt{set} a \texttt{get} ve svém názvu, jsou jednoduše odlišeni tak, že gettery neberou žádný parametr a settery berou více než jeden.
Názvy šablon a konceptů používají \texttt{CamelCase}.
Soukromé atributy třídy končí podtržítkem.

\subsection{Uspořádání projektu}
Projekt je rozdělen do 3 hlavních adresářů: \textit{include}, \textit{src} a \textit{test}.
Adresář \textit{include} obsahuje obchodovací framework a vybrané hlavičky z knihovny CppCoro.
Organizace frameworku je inspirovaná knihovnou \textit{Boost.Asio}.
Definice a deklarace tříd jsou uloženy společně v jednom souboru s příponou \textit{.hpp}.
Hierarchie složek se řídí jmennými prostory, například třídu \texttt{trading::bazooka::long\_strategy} lze nalézt v souboru \textit{/include/trading/bazooka/long\_strategy}.
Framework lze zahrnout jako celek pomocí \textit{trading.hpp} nebo jednotlivě po souborech.

Adresář \textit{src} se skládá ze souboru \textit{main.cpp}, Jypiter Notebooků používaných pro vizualizaci, vstupních a výstupních dat.
Testy jsou organizovány stejně jako třídy obchodovacího frameworku.
Projekt je kompilován pomocí souborů \textit{CMakeLists.txt}, které obsahují seznam souborů ke kompilaci, nastavení kompilátoru a informace pro hledání externích knihoven.
Vytváří 2 spustitelné soubory \textit{backesting} pro použití optimalizátorů a \textit{test\_} pro provádění testů.


\chapter{Simulace obchodování}

\section{Strategie}

\subsection{Indikátor}
Indikátor může být typu \texttt{trading::sma} nebo \texttt{trading::ema}.
Běžným způsobem, jak umožnit oba typy, by bylo použití runtime polymorfismu prostřednictvím virtuálních funkcí.
Oba indikátory by musely dědit ze společné třídy a implementovat její virtuální funkce.
Instance třídy by musela být inicializována na haldě namísto zásobníku a dalo by se k ní přistupovat pomocí ukazatele na společnou třídu.
Jak dynamická alokace, tak použití virtuálních funkcí způsobují režii navíc.
Existuje několik nedávných přednášek z \textit{C++ konference} (CppCon) \cite{gobel-virtual, bogosavljevic-virtual}, které jsou zaměřeny na způsoby, jak se vyhnout používání virtuálních funkcí.
V obou přednáškách jsou zapojeny prvky moderního C++.

Jako nejpřirozenější se v tomto případě nabízí použití třídy \texttt{std::variant} zavedené standardem C++17.
Třída funguje jako úložiště pro různé typy.
Pro uložení instance daného typu používá pole bajtů, který musí mít velikost největšího uložitelného typu.
Jako třídní šablonové parametry přebírá seznam typů, které mohou být v objektu uloženy.
Jakmile je objekt inicializován, lze použít funkci \texttt{std::get} pro přístup k hodnotě v něm uložené.
Funkce přijímá šablonový argument, který je buď indexem typu, nebo samotným typem, který by měl být aktuálně v instanci uložen.
Pokud je uložen jiný typ, tak volání funkce způsobí vyhození \texttt{std::bad\_variant\_access} výjimky.

Dalším způsobem přístupu k uložené hodnotě je použití funkce \texttt{std::visit}.
Vyžaduje 2 argumenty, první je volatelný objekt a druhý instance \texttt{std::variant}.
Při volání nejprve získá hodnotu uloženou v instanci a poté ji předá volatelnému objektu.
V případě indikátorů může být použita při aktualizaci (viz \ref{lst:update:indicator}).

\begin{lstlisting}[caption={~Aktualizace indikátoru pomocí std::visit},label={lst:update:indicator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
std::variant<sma, ema> ma{sma{30}};
bool ready = std::visit([&value](auto& indic) {
    return indic.update(value);
}, ma);
\end{lstlisting}

Byla vytvořena třída \texttt{bazooka::indicator}, aby bylo možné objekt správně zapouzdřit a spravovat.
Třída má pouze jeden členský atribut \texttt{data\_} typu \texttt{std::variant<sma, ema>}, který je používán pro uložení indikátoru.
Metody používají \texttt{std::visit} pro přístup a změnu hodnoty indikátoru.
Sdílí stejné rozhraní s třídami \texttt{sma} a \texttt{ema}.

\subsection{Simulátor}
Obchodování lze simulovat pomocí třídy \texttt{simulator}, která uchovává a připravuje historická data pro simulaci a umožňuje její provedení.
Hlavním účelem třídy je použít ji jako objektivní funkci během optimalizace.
Obchodování lze pozorovat pomocí pozorovatelů.
Tímto způsobem lze například použít instanci třídy \texttt{bazooka::statistics::collector} ke sběru statistik nebo časových řad pro vykreslování grafu pomocí třídy \texttt{chart\_series::collector}.

Při konstrukci jsou předány simulátoru historické ceny v podobě minutových svíček.
Pro rozhodování se používají minutové uzavírací ceny.
Ceny používané pro aktualizaci indikátorů jsou získány tak, že jsou minutové svíčky nejprve převzorkovány pomocí \texttt{resampler} na požadované časové období a zprůměrovány pomocí zvolené průměrovací metody.
Pokud je například doba převzorkování 30 minut a metoda průměrování \textit{OHLC4}, tak jsou svíčky nejprve převzorkovány na 30minutové svíčky a poté zprůměrovány pomocí \texttt{candle::ohlc4}.

Proces převzorkování probíhá tak, že za dané období se otevírací cena první svíčky stane otevírací cenou převzorkované svíčky a uzavírací cena poslední svíčky se stane její uzavírací cenou.
Vysoká a nízká cena jsou nejvyšší a nejnižší ceny v daném období.
Jelikož je převzorkování poměrně časově náročné, tak se provádí pouze jednou v konstruktoru, takže se neopakuje při každém volání simulátoru.

\begin{lstlisting}[caption={~Implementace simulace obchodování},label={lst:simulator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class Trader, class... Observer>
void operator()(Trader&& trader, Observer&... observers)
{
    amount_t min_allowed_equity{100};
    auto indic_prices_it = indic_prices_.begin();
    price_point curr;

    (observers.begin(trader, prices_.front()), ...);
    for (std::size_t i{0}; i<prices_.size(); i++) {
        curr = prices_[i];
        if (trader.equity(curr.data)>min_allowed_equity) {
            (observers.traded(trader, trader.trade(curr), curr), ...);

            if (trader.has_active_position())
                (observers.position_active(trader, curr), ...);

            // update indicators
            if (i && (i+1)%resampling_period_==0)
                if (trader.update_indicators((*indic_prices_it++)))
                    (observers.indicator_updated(trader, curr), ...);
        }
    }
    (observers.end(trader, prices_.back()), ...);
}
\end{lstlisting}

\subsection{Statistiky}
Nezbytnou součástí optimalizace jsou statistiky.
Mohou být použity k formulaci optimalizačního kritéria a omezujících podmínek.
Statistiky, které jsou společné pro všechny obchodní strategie, jsou reprezentovány třídou \texttt{statistics} a jsou rozšířeny pro \textit{Bazooka} obchodovací strategii \texttt{bazooka::statistics}.

Inicializuje se pomocí počátečního zůstatku.
Statistiky aktualizovány pomocí metod pro aktualizaci \texttt{update\_equity()} nebo setrů \texttt{set\_final\_balance}.
Hodnoty lze získat pomocí getrů.
Některé hodnoty, jako je celkový zisk, lze získat buď jako částku nebo v procentech.
Pro upřesnění jednotky a se používá značka \texttt{percent} nebo \texttt{amount} \ref{lst:use:unit:tag} při volání metody.

\begin{lstlisting}[caption={~Metody pro získání celkového ziskz v různých jednotkách},label={lst:use:unit:tag},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class T>
requires std::same_as<T, amount>
amount_t total_profit() const
{
    return final_balance_-init_balance_;
}
template<class T>
requires std::same_as<T, percent>
amount_t total_profit() const
{
    return ((final_balance_-init_balance_)/init_balance_)*100;
}
\end{lstlisting}

Všechny statistiky související se ziskem jsou sledovány pomocí \texttt{profit\_statistics}, které lze použít k získání hrubého zisku, hrubé ztráty nebo faktoru zisku.
Dále jsou sledovány statistiky související s pohybem pomocí \texttt{motion\_statistics}, které poskytují minimální a maximální hodnotu, maximální vzestupný pohyb a sestupný pohyb.
Vzestupný pohyb je sledován pomocí \texttt{run\_up\_tracker} a sestupný pomocí \texttt{drawdown\_tracker}.
Jsou sledovány čistá hodnota a uzavírací zůstatek.
Hodnoty lze opět vyjádřit v procentech nebo částkách.

Do třídy \texttt{bazooka::statistics} byl přidán čítač otevíracích objednávek pro jednotlivé nákupní úrovně.
Nese informace o tom, kolikrát bylo dosaženo jednotlivých úrovní nákupu, a může tak pomoci lépe porozumět tomu, jak strategie chová.

\chapter{Optimalizace}

\iffalse
Jednotlivé hodnoty jsou uloženy v instancích třídy \texttt{trading::fraction}, která je inspirována třídou \texttt{boost::rational}.
Je však mnohem jednodušší a méně obecná.
Předpokládá, na rozdíl od \texttt{boost::rational}, že zlomky, mezi kterými se provádějí aritmetické operace, mají stejného jmenovatele.
Porušení tohoto předpokladu vede k nedefinovanému chování.
Celá sekvence je uložena v instanci třídy \texttt{std::array}, což také znamená, že velikost sekvence musí být známa v době kompilace.
Pokud by to v budoucnu bylo nalezeno za nevhodné, může být nahrazena třídou \texttt{std::vector} nebo \texttt{boost::container::small\_vector} ke snížení počtu malých dynamických alokací.
\fi

\section{Návrh a generování stavového prostoru}
Pro optimalizaci byly vybrány 4 konfigurační proměnné: typ indikátoru, perioda indikátoru, úrovně a velikosti nákupů.
Hodnoty proměnných lze generovat buď systematicky, nebo náhodně.
Důležitým aspektem, který bylo nutné dodržet, bylo, že obě verze generátorů musí generovat hodnoty ze stejného vyhledávacího prostoru, jinak by byly výsledky jednotlivých optimalizačních metod nesrovnatelné.

Generátory sdílejí společné rozhraní, jakmile jsou vytvořeny, lze je použít voláním volacího operátoru třídy.
Náhodné generátory mají operátor přetížen.
Specializace přebírá jeden argument představující původní hodnotu používanou při generování následující hodnoty.
Systematické generátory vracejí korutiny a náhodné generátory vracejí přímo datové typy představující konfigurační proměnné.
Systematické generátory vracejí stejné hodnoty pouze jednou a náhodné generátory je mohou vrátit vícekrát.
V ideálním případě by měly náhodné generátory vracet stejné hodnoty se stejnou pravděpodobností.

\subsection{Typ indikátoru}
Typ indikátoru je reprezentován enumerační třídou \texttt{indicator\_tag} se dvěma možnými hodnotami: \texttt{indicator\_tag::ema} a \texttt{indicator\_tag::sma}.
Jediný způsob, jak parametrizovat tuto proměnnou, je použít buď jednu z hodnot, nebo obě.
Hodnoty jsou stejného typu, takže je lze uložit do pole.
Jelikož je jeho velikost malá a maximální velikost je známa v době kompilace, tak lze použít \texttt{etl::vector} k uložení hodnot pro generování.
Hodnoty lze náhodně rovnoměrně generovat pomocí instance třídy \tttext{std::uniform\_int\_distribution}.

\subsection{Perioda indikátoru}
SMA i EMA mají parametr perioda $p>1$.
Oba generátory generují hodnoty v intervalu $[f, t]$ s krokem $s$, kde $((f>t\implies((f-t) \mod s)=0 \land s<0) \land (t<f\implies((t-f) \mod s)=0 \land s>0)) \land s\neq0 \land t\neq f$.
Počet možných výstupních hodnot je roven $n=\frac{|t-f|}{s}+1$.

\subsubsection{Náhodné generování}
Při generování bez počáteční periody je nejprve pomocí \tttext{std::uniform\_int\_distribution} vygenerována hodnota $ v \in [\frac{p_{min}}{s}, = \frac{p_{max}}{s}$], kde $p_{min}=min(f, t) \land p_{max}=max(f, t)$, která je následně přeškálována $p_o=v\cdot s \land p_o \in [p_{min}, p_{max}]$.

Při generování hodnoty z počátku $o$ používá generátor navíc parametr $k\in[1,n/2]$.
Například, když $f=1$, $t=5$, $s=1$, $o=3$ a $k=1$, pak jsou všechny možné výstupní hodnoty periody $ p_o \in [o-(k\cdot s), o+(k\cdot s)]=[2, 4]$.
Jediné úskalí nastává na okrajích intervalu, kdy mohou být hodnoty generovány z 2 podintervalů. Například, když $f=1$, $t=5$, $s=1$ a $k=1$, pak jsou všechny možné výstupní periody $p_o \in [1, 2] \cup [5, 5]$.
Jelikož jsou periody generovány pomocí datového typu integer, který může nabývat i záporných hodnot, lze nejprve vygenerovat hodnotu $ w \in [o-(k\cdot s), o+(k\cdot s)]$, výslednou periodu získat $(w<p_{min}\implies(p_o=w+(n*|s|))) \land (w>p_{max}\implies(p_o=w-(n*|s|))) \land (w \in [p_{min}, p_{max}]\implies p_o=w)$.

\subsection{Úrovně nákupu}
Pro úrovně nákupu platí, že $\{l_0, l_1,\dots,l_n\} \in \mathbb{Q} \cap [0, 1] \land n>0 \land [\forall i \in \{0,\dots,n-1\} : l_i > l_{i+1}]$.
Příkladem takové sekvence racionálních čísel může být $\{\frac{1}{2}, \frac{1}{3}, \frac{1}{4}\}$.
Generátory jsou parametrizovány pomocí parametru $u\geq n$, který označuje počet jedinečných zlomků, které se mohou objevit v sekvenci.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=u+1$.
Pro $n=3$, $u=4$ jsou všechny možné platné sekvence: $\{\frac{4}{5}, \frac{3}{5}, \frac{2}{5}\}, \{\frac{4}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{4}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{2}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Sekvence jsou generovány rekurzivně (viz \ref{lst:systematic:levels_generator}), protože se počet smyček \texttt{for} liší v závislosti na velikosti sekvence $n$.
Smyčky jsou na sobě závislé, následující (hlubší) smyčka musí znát předchozí hodnotu čitatele.
Nejvnitřnější smyčka vrací výslednou sekvenci.

\begin{lstlisting}[caption={~Metody pro systematické generování úrovní nákupu},label={lst:systematic:levels_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_levels>
    requires (depth==n_levels)
    value_type generate(std::size_t) { co_yield this->levels_; }
    
    template<std::size_t depth = 0>
    requires (depth<n_levels)
    value_type generate(std::size_t prev_num)
    {
        for (std::size_t num{--prev_num}; num>n_levels-depth-1; num--) {
            this->levels_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}
Instance třídy \texttt{trading::random::levels\_generator} má mezi svými atributy pole se všemi možnými hodnotami výstupní sekvence.
Při generování náhodné sekvence bez počátku nejprve tyto hodnoty zamíchá, seřadí prvních $n$ prvků v sestupném pořadí a nakonec je zkopíruje do výstupního pole.

Náhodné generování na základě počáteční sekvence je složitější.
Používá parametr $k \in [1, n] $, který je předán instanci při její konstrukci.
Udává počet prvků počáteční sekvence, které by měly být změněny.
Při generování je nejprve náhodně vybráno $n-k$ prvků, které budou zachovány z původní sekvence, a jsou uloženy do instance \texttt{etl::flat\_set}, což je kontejner pevné velikosti, který ukládá jedinečné prvky v určeném pořadí.
Dále je zamícháno pole se všemi možnými hodnotami.
Ve smyčce \texttt{while} se pak hodnoty pokouší vložit do sady s jedinečnými hodnotami, dokud není sada plná.
Nakonec jsou hodnoty překopírovány ze sady do výstupního pole.

\subsection{Velikosti nákupu}
Pro velikosti nákupu platí, že $ (\-s_0, s_1,\dots,s_n)\ \in \mathbb{Q} \cap [0, 1] \land n>1 \land \sum_{i=0}^{n} s_i = 1 $.
Příkladem takové sekvence může být $ (\frac{1}{4}, \frac{2}{4}, \frac{1}{4})\ $.
Generátory jsou parametrizovány pomocí parametru $u\geq 1$, který označuje počet jedinečných zlomků, které se mohou v sekvenci objevit.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=n+u-1$.
Pro $n=3$, $u=3$ jsou všechny možné platné sekvence: $\{\frac{1}{5}, \frac{1}{5}, \frac{3}{5}\}, \{\frac{1}{5}, \frac{2}{5}, \frac{2}{5}\}, \{\frac{1}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{2}{5}, \frac{1}{5}, \frac{2}{5}\}, \{\frac{2}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{1}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Velikosti nákupů \ref{lst:systematic:sizes_generator} jsou systematicky generovány podobně jako úrovně nákupů.
Používá se také rekurze, každá smyčka \texttt{for} předává součet zbývajících čitatelů následující smyčce.
Maximální lokální čitatel má buď hodnotu globálního maximálního čitatele, nebo součet zbývajících čitatelů snížený o jedna.

\begin{lstlisting}[caption={~Metody pro systematické generování velikostí nákupu},label={lst:systematic:sizes_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_sizes>
    requires (depth+1==n_sizes)
    value_type generate(std::size_t remaining)
    {
        this->sizes_[depth] = fraction_t{remaining, this->denom_};
        co_yield this->sizes_;
    }

    template<std::size_t depth = 0>
    requires (depth+1<n_sizes)
    value_type generate(std::size_t remaining)
    {
        std::size_t max = (remaining>this->max_num_)
            ? this->max_num_ : remaining-1;
        for (std::size_t num{1}; num<=max; num++) {
            this->sizes_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(remaining-num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}

\section{Optimalizátory}

Když jsou volány heuristické optimalizátory, tak přijímají mezi objekty typu pozorovatel jako své argumenty.
Pozorovatelé jsou upozorňovány na události, ke kterým dochází během optimalizace.
Průběh optimalizace mohou hlásit nebo ukládat.
Příkladem události, která může nastat během optimalizace simulovaného ochlazování, je snížení teploty nebo přijetí lepšího stavu.
Pozorovatelé jsou vždy posledním parametrem uloženým jako sada parametrů šablony.
Tímto způsobem lze přijmout více pozorovatelů nebo žádný.

\subsection{Hrubá síla}
Algoritmus hrubé síly prochází celým vyhledávacím prostorem a zajišťuje nalezení optimálního řešení.
Je vhodný pro relativně malé vyhledávací prostory a může pomoci lépe porozumět vlastnostem cenové funkce.

Vyhledávací prostor je generován pomocí systematických generátorů, které jsou volány ve vnořených smyčkách \texttt{for} (viz \ref{lst:systematic:states_generator}).
Nejvnitřnější cyklus vrací konfiguraci jako korutinu typu \texttt{cppcoro::generator}.
Vytvoření vyhledávacího prostoru tímto způsobem je jednodušší než navrhování vlastního iterátoru, protože smyčky mohou být na sobě závislé.

\begin{lstlisting}[caption={~Ukázka generování systematického stavového prostoru},label={lst:systematic:states_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
auto search_space = [&]() -> cppcoro::generator<config_type> {
    for (std::size_t period: periods_gen())
        for (const auto& tag: tags)
            for (const auto& levels: levels_gen())
                for (const auto& open_sizes: sizes_gen())
                    co_yield config_type{tag, period, levels, open_sizes};
};
\end{lstlisting}

Vzhledem k tomu, že jsou jednotlivé stavy na sobě nezávislé, může být vyhledávání paralyzováno.
Paralelizaci lze provést pomocí direktiv z knihovny \textit{OpenMP}.
Jelikož je vyhledávací prostor předáván jako korutina, lze jej paralelizovat pouze pomocí taskového paralelismu použitím direktivy \texttt{task}.

Implementaci paralelizace lze vidět ve výpise \ref{lst:brute-force}.
Nejprve je použita direktiva \texttt{parallel} k vytvoření paralelního regionu, který vytváří, provádí a ukončuje jednotlivá vlákna.
Následně je pomocí direktivy \texttt{single} proveden cyklus \texttt{for} právě jedním vláknem.
Uvnitř cyklu jsou vytvářeny jednotlivé úlohy pomocí direktivy \texttt{task} a prováděny paralelně jednotlivými vlákny.
Každé vlákno nejprve zavolá cenovou funkci k získání ceny.
Vytvoří stav, který se skládá z konfigurace a ceny.
Pokud stav splňuje omezující podmínky, je v kritické sekci výsledek aktualizován.
Je nutné použít synchronizaci, protože je výsledek modifikován více vlákny.
Algoritmus je zapouzdřen ve třídě \texttt{brute\_force::parallel::optimizer}.

\begin{lstlisting}[caption={~Optimalizace pomocí algoritmu hrubé síly},label={lst:brute-force},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
#pragma omp parallel
{
    #pragma omp single
    {
        for (const auto& config: search_space()) {
            #pragma omp task
            {
                auto curr_state = state{config, cost(config)};
                if (constrains(curr_state)) {
                    #pragma omp critical
                    result.update(curr_state);
                }}}}}
\end{lstlisting}

\subsection{Simulované ochlazování}
Algoritmus simulovaného ochlazování je implementován třídou \texttt{simulated\_annealing::optimizer}.
Třída má pouze několik členských atributů: současnou, počáteční a minimální teplotu, počet iterací a současný stav.
Jiné části algoritmu jako chlazení, ohodnocení horšího stavu a nalezení sousedního stavu jsou specifické pro řešený problém, proto jsou předány jako argumenty při volání instance objektu.

Bylo implementováno několik chladicích algoritmů vycházejících ze srovnávajícího článku \cite{cooling-comparison}.
Všechny jsou umístěny v souboru \texttt{simulated\_annealing/cooler.hpp}.
Většina je parametrizována parametrem decay, který se používá k řízení rychlosti snižování teploty.
Správnost jeho hodnoty závisí na algoritmu chlazení a ověřuje se při inicializaci konkrétního objektu.
Chladiče používají návrhový vzor strategie, který funguje následovně, namísto předávání seznamu argumentů při volání chladiče je jako argument předán samotný optimalizátor.
Algoritmus chlazení si tak může sám zvolit, které atributy heuristiky použije k výpočtu následující teploty a změnit její hodnotu může pomocí setteru třídy.
Příklad implementace chladiče lze vidět na \ref{lst:cooling}.

\begin{lstlisting}[caption={~Ukázka implementace chlazení třídy \texttt{simulated\_annealing::exp\_mul\_cooler }},label={lst:cooling},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
void operator()(SimulatedAnnealing& optimizer)
{
    optimizer.current_temperature(optimizer.start_temperature()*
        std::pow(this->decay_, optimizer.it()));
}
\end{lstlisting}

Volající operátor optimalizátoru přebírá většinu parametrů jako koncepty.
Výhodou použití konceptů namísto klasických šablonových argumentů je to, že lze definovat omezení, která musí předaný objekt dodržovat.
U volatelných argumentů lze například pomocí konceptů definovat typy vstupních a výstupních argumentů.
Koncept definující omezení pro chladící algoritmu lze vidět na \ref{lst:cooling:concept}.
Chyby generované kompilátorem při použití objektu se špatným rozhraním jsou často čitelnější a přímější při použití konceptů než samotných šablon.

\begin{lstlisting}[caption={~Koncept pro kontrolu chladícího algoritmu},label={lst:cooling:concept},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class ConcreteCooler, class SimulatedAnnealing>
concept Cooler = std::invocable<ConcreteCooler, SimulatedAnnealing&> &&
std::same_as<void,std::invoke_result_t<ConcreteCooler,SimulatedAnnealing&>>;
\end{lstlisting}

Algoritmus pro nalezení náhodného souseda je implementován pomocí třídy \texttt{bazooka::neighbor}.
Ke generování sousední konfigurace využívá náhodné generátory, které na základě aktuální hodnoty generují následující hodnotu.
Náhodně je vždy změněn pouze jeden konfigurační parametr.
Pro realizaci equilibria byl implementován algoritmus založený na pevném počtu prohledávaných sousedních stavů \texttt{simulated\_annealing::fixed\_iteration\_equilibrium}.

Implementaci algoritmu lze vidět ve výpisu \ref{lst:simulated:annealing}.
Během optimalizace dochází k několika událostem, které jsou hlášeny pozorovatelům.
Pro sběr dat o průběhu optimalizace byla implementována třída \texttt{simulated\_annealing::progress\_collector}.
Za účelem logování byla vytvořena třída \texttt{simulated\_annealing::progress\_reporter}.

\begin{lstlisting}[caption={~Implementace simulovaného ochlazování},label={lst:simulated:annealing},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
curr_state_ = state{init_config, objective(init_config)};
(observers.begin(*this), ...);

for (; curr_temp_>min_temp_; it_++) {
    while (equilibrium()) {
        Config config = neighbor(curr_state_.config);
        auto candidate = state{config, objective(config)};

        if (result.compare(candidate, curr_state_)) {
            curr_state_ = candidate;
            (observers.better_accepted(*this), ...);

            if (constraints(curr_state_))
                result.update(curr_state_);
        }
        else {
            double diff = appraiser(curr_state_, candidate);
            double threshold = std::exp(-diff/curr_temp_);

            if (rand_prob_gen_()<threshold) {
                curr_state_ = candidate;
                (observers.worse_accepted(*this, threshold), ...);
            }
        }
    }
    cooler(*this);
    (observers.cooled(*this), ...);
}
(observers.end(*this), ...);
\end{lstlisting}

\subsection{Genetický algoritmus}
Genetický algoritmus je implementován třídou \texttt{genetic\_algorithm::optimizer}.
Má pouze 2 atributy třídy, počet iterací a populaci, další části algoritmu jsou poskytovány při jeho volání.
Populace je uložena pomocí třídy \texttt{std::vector}, která se spravuje dynamicky alokovaného pole prvků.
Bylo dbáno na to, aby došlo k co nejmenšímu počtu realokací v průběhu optimalizace, a to opětovným použitím již alokovaného pole pomocí metody \texttt{clear} a použití metody \texttt{reserve}, kdykoli je dopředu známa velikost pole.
Jinak by docházelo ke zbytečnému zpomalování optimalizace.

Pro mutaci lze použít instanci třídy \texttt{bazooka::neighbor}.
Algoritmus pro křížení je implentován třídou \texttt{bazooka::crossover}.
Při křížení se používají všechny konfigurační proměnné, a proto pro každou z nich je implementován operátor křížení.
O tom, zda potomek obdrží periodu indikátoru nebo typ indikátoru od své matky nebo otce, se rozhoduje hodem mincí.
Pro křížení úrovní a velikostí nákupů byly vytvořeny vlastní třídy.

Křížení úrovní nákupu je implementováno třídou \texttt{bazooka::levels\_crossover}.
Funguje tak, že genetickou informaci od otce a matky vloží do společného pole typu \texttt{etl::vector}, které na rozdíl od \texttt{std::vector} používá statickou alokaci místo dynamické.
Geny jsou poté náhodně zamíchány a poté vkládány ve \texttt{while} cyklu do instance \texttt{elt::flat\_set} do jejího naplnění.
Hodnoty jsou nakonec překopírovány do výstupního pole.
Algoritmus má několik vlastností, jednou z nich je, že pokud jsou rodiče stejní, bude i potomek stejný.
Pokud mají společný gen, je větší šance, že bude vybrán.

Křížení velikostí nákupů je implementováno třídou \texttt{bazooka::sizes\_crossover}.
Nejmenší hodnoty rodičů jsou použity jako základ pro potomka.
Dále jsou nákupní velikosti dítěte náhodně zvyšovány v cyklu \texttt{while} tak, aby velikost nákupu nikdy nebyla větší než nejvyšší hodnota rodiče.
Smyčka končí, jakmile je součet všech velikostí roven 1.
Výsledné hodnoty potomků se tedy budou vždy pohybovat v rozmezí hodnot rodičů.
Pokud rodiče nejsou stejní, potomek je jiný, ale stále je podobný svým rodičům.

Pro výběr rodičů byl realizován ruletový výběr \texttt{genetic\_algorithm::roulette\_selection}.
Interně používá instanci třídy \texttt{std::discrete\_distribution} pro výběr rodičů.
Zdatnost každého jednotlivce představuje váhu, čím vyšší je váha, tím pravděpodobněji bude daný jedinec vybrán jako rodič.

Byl implementován \texttt{genetic\_algorithm::random\_matchmaker} algoritmus náhodného párování rodičů.
Rodiče jsou nejprve náhodně zamícháni a následně párováni.
Celkový počet rodičů nemusí být dělitelný počtem vybíraných n-tic, takže někteří rodiče se mohou spárovat vícekrát.

Poslední část algoritmu se zabývá nahrazením původní generace za novou.
Byly implementovány dva přístupy.
En block nahrazování reprezentované třídou \texttt{genetic\_algorithm::en\_block\_replacement} zachovává pouze děti k vytvoření nové generace.
Druhý přístup používá elitismus a je implementován třídou \texttt{genetic\_algorithm::elitism\_replacement}.
Třída má parametr $l\in[0, 1]$ představující zlomek vybraných elitních rodičů.
Nejprve seřadí rodiče podle zdatnosti a poté jimi nahradí prvních n dětí.

Jak je vidět ve výpisu \ref{lst:genetic:algorithm}, opět lze předat při volání instance třídy objekty typu pozorovatel, které jsou upozorňováni na události nastávající v průběhu optimalizace.
Data o průběhu optimalizace lze shromažďovat pomocí \texttt{genetic\_algorithm::progress\_collector} a zaznamenávat pomocí \texttt{genetic\_algorithm::progress\_reporter}.

\begin{lstlisting}[caption={~Implementace genetického algoritmu},label={lst:genetic:algorithm},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
population_.clear(), population_.reserve(init_genes.size());
for (const auto& genes: init_genes)
    population_.emplace_back(std::move(individual{genes,
        compute_fitness(genes)}));

std::vector<individual> parents, children;
(observers.begin(*this), ...);
for (; population_.size() && !termination(*this); it_++) {
    parents.clear();
    selection(sizer(population_.size()), population_, parents);

    // mate
    children.clear();
    for (const auto& mates: match(parents))
        for (auto&& genes: crossover(mates)) {
            genes = mutation(std::move(genes));
            auto child = individual{genes, compute_fitness(genes)};
            children.template emplace_back(std::move(child));
        }

    // replace
    population_.clear();
    replacement(parents, children, population_);
    (observers.population_updated(*this), ...);
};
(observers.end(*this), ...);
return population_;
\end{lstlisting}

\subsection{Tabu prohledávání}
Tabu prohledávání je implementováno třídou \texttt{tabu\_search::optimizer}.
Má 3 třídní atributy: počet iterací, aktuální a nejlepší stav.
Pro ukládání zakázaných tahů byla implementována třída \texttt{bazooka::moves\_memory}.
Ukládá pouze konfigurační atributy, které byly změněny, nikoli celé konfigurace.
Perioda a typ indikátoru jsou zapamatovány tak, jak jsou.
Hodnoty úrovně a velikosti nákupu, které nebyly změněny, se vynulují.
K ukládání úrovní a velikostí nákupu se používá \texttt{std::map}.

Jelikož existují 4 konfigurační proměnné, z nichž se vždy mění pouze jedna, tak se tah ukládá do instance třídy \texttt{std::variant}, která je zapouzdřena do instance třídy \texttt{bazooka::movement}.
Vzhledem k tomu, že úrovně a velikosti nákupu jsou reprezentovány stejným datovým typem, polem zlomků, je nutné implementovat způsob, jak je rozlišit.
Třída proto obsahuje výčtovou třídu zvanou \texttt{indices}, ke které lze přistupovat zvenčí.
Lze ji použít ve výrazech \texttt{switch} \ref{lst:movement:usage}.
Tah lze uložit a zpřístupnit pomocí setterů a getterů.

\begin{lstlisting}[caption={~Použití třídy \texttt{bazooka::movement}},label={lst:movement:usage},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
bool contains(const move_type& move) const
{
    switch (move.indices()) {
    case move_type::indices::tag:
        return indic_mem_.contains(move.tag);
    case move_type::indices::period:
        return period_mem_.contains(move.period());
    case move_type::indices::levels:
        return levels_mem_.contains(move.levels());
    default:
        return sizes_mem_.contains(move.open_sizes());
    }
}
\end{lstlisting}

Hodnoty vložené do paměti v ní zůstávají po určitý počet iterací.
Při každé iteraci se počet iterací sníží pouze pro konfigurační parametr, který byl změněn.
Pevný počet operací lze nastavit pomocí instance třídy \texttt{tabu\_search::fixed\_tenure} pro paměť každého konfiguračního parametru.

Sousední konfigurace lze vygenerovat pomocí \texttt{bazooka::neighbor}, která vrací konfiguraci včetně tahu.
Velikost sousedství říká, kolik sousedních konfigurací by mělo být prohledáno v jedné iteraci.
Při volání instance optimalizátoru lze také použít pozorovatele \ref{lst:tabu:search}.

\begin{lstlisting}[caption={~Implementace genetického algoritmu},label={lst:tabu:search},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
best_ = curr_ = state{init, compute_fitness(init)};
state candidate, origin;
typename TabuList::move_type curr_move, candidate_move;

(observers.begin(*this), ...);
for (; !terminate(*this); it_++) {
    // explore neighborhood
    origin = curr_;
    std::tie(curr_.config, curr_move) = neighbor(origin.config);
    curr_.fitness = compute_fitness(curr_.config);

    for (std::size_t i{0}; i<neighborhood_size(*this)-1; i++) {
        std::tie(candidate.config,candidate_move)=neighbor(origin.config);

        if (!tabu_list.contains(candidate_move)) {
            candidate.fitness = compute_fitness(candidate.config);

            if (optim_criteria(candidate.fitness, curr_.fitness)
                || aspire(candidate, *this)) {
                curr_ = candidate;
                curr_move = candidate_move;
            }}}

    if (optim_criteria(curr_.fitness, best_.fitness))
        best_ = curr_;

    tabu_list.forget(curr_move);
    tabu_list.remember(curr_move.index());
    (observers.iteration_passed(*this, tabu_list), ...);
}
(observers.end(*this), ...);
\end{lstlisting}
