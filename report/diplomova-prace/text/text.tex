% Do not forget to include Introduction
%---------------------------------------------------------------
% \chapter{Introduction}
% uncomment the following line to create an unnumbered chapter
\chapter*{Introduction}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

Backtesting je nezbytnou součástí při vývoji obchodní strategie.
Ukazuje, jak by si strategie vedla, kdyby byla nasazena v minulosti.
Cílem je lépe pochopit fungování dané strategie, zjistit, kde jsou její úskalí a ideálně je opravit před nasazením do produkce.
Strategie jsou často parametrizované a při obchodování s různými aktivy mohou fungovat různé kombinace hodnot.
Pro maximalizaci ziskovosti strategie a snížení rizik je zapotřebí rychlý a spolehlivý způsob optimalizace těchto parametrů \cite{efficient-backtesting}.

Nejjednodušší a časově nejnáročnější způsob, jak najít optimální nastavení, by bylo prohledat všechny možné kombinace.
Největší výhodou tohoto přístupu je, že zaručuje nalezení nejlepšího možného řešení, nicméně je v praxi nepoužitelný pro velké množství možností, protože nedokončí v přiměřeně krátké době \cite{efficient-backtesting}.

\chapter{Design}

\subsection{Jmenné konvence}
Konvence pojmenování jsou převzaty z \textit{STL} a \textit{Boost} knihoven.
Názvy tříd a funkcí používají \texttt{snake\_case}.
Metody nastavení a čtení atributů třídy nepoužívají \texttt{set} a \texttt{get} ve svém názvu, jsou jednoduše odlišeni tak, že gettery neberou žádný parametr a settery berou více než jeden.
Názvy šablon a konceptů používají \texttt{CamelCase}.
Soukromé atributy třídy končí podtržítkem.

\subsection{Uspořádání projektu}
Projekt je rozdělen do 3 hlavních adresářů: \textit{include}, \textit{src} a \textit{test}.
Adresář \textit{include} obsahuje obchodovací framework a vybrané hlavičky z knihovny CppCoro.
Organizace frameworku je inspirovaná knihovnou \textit{Boost.Asio}.
Definice a deklarace tříd jsou uloženy společně v jednom souboru s příponou \textit{.hpp}.
Hierarchie složek se řídí jmennými prostory, například třídu \texttt{trading::bazooka::long\_strategy} lze nalézt v souboru \textit{/include/trading/bazooka/long\_strategy}.
Framework lze zahrnout jako celek pomocí \textit{trading.hpp} nebo jednotlivě po souborech.

Adresář \textit{src} se skládá ze souboru \textit{main.cpp}, Jypiter Notebooků používaných pro vizualizaci, vstupních a výstupních dat.
Testy jsou organizovány stejně jako třídy obchodovacího frameworku.
Projekt je kompilován pomocí souborů \textit{CMakeLists.txt}, které obsahují seznam souborů ke kompilaci, nastavení kompilátoru a informace pro hledání externích knihoven.
Vytváří 2 spustitelné soubory \textit{backesting} pro použití optimalizátorů a \textit{test\_} pro provádění testů.


\chapter{Simulace obchodování}

\section{Strategie}

\subsection{Indikátor}
Indikátor může být typu \texttt{trading::sma} nebo \texttt{trading::ema}.
Běžným způsobem, jak umožnit oba typy, by bylo použití runtime polymorfismu prostřednictvím virtuálních funkcí.
Oba indikátory by musely dědit ze společné třídy a implementovat její virtuální funkce.
Instance třídy by musela být inicializována na haldě namísto zásobníku a dalo by se k ní přistupovat pomocí ukazatele na společnou třídu.
Jak dynamická alokace, tak použití virtuálních funkcí způsobují režii navíc.
Existuje několik nedávných přednášek z \textit{C++ konference} (CppCon) \cite{gobel-virtual, bogosavljevic-virtual}, které jsou zaměřeny na způsoby, jak se vyhnout používání virtuálních funkcí.
V obou přednáškách jsou zapojeny prvky moderního C++.

Jako nejpřirozenější se v tomto případě nabízí použití třídy \texttt{std::variant} zavedené standardem C++17.
Třída funguje jako úložiště pro různé typy.
Pro uložení instance daného typu používá pole bajtů, který musí mít velikost největšího uložitelného typu.
Jako třídní šablonové parametry přebírá seznam typů, které mohou být v objektu uloženy.
Jakmile je objekt inicializován, lze použít funkci \texttt{std::get} pro přístup k hodnotě v něm uložené.
Funkce přijímá šablonový argument, který je buď indexem typu, nebo samotným typem, který by měl být aktuálně v instanci uložen.
Pokud je uložen jiný typ, tak volání funkce způsobí vyhození \texttt{std::bad\_variant\_access} výjimky.

Dalším způsobem přístupu k uložené hodnotě je použití funkce \texttt{std::visit}.
Vyžaduje 2 argumenty, první je volatelný objekt a druhý instance \texttt{std::variant}.
Při volání nejprve získá hodnotu uloženou v instanci a poté ji předá volatelnému objektu.
V případě indikátorů může být použita při aktualizaci (viz \ref{lst:update:indicator}).

\begin{lstlisting}[caption={~Aktualizace indikátoru pomocí std::visit},label={lst:update:indicator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
std::variant<sma, ema> ma{sma{30}};
bool ready = std::visit([&value](auto& indic) {
    return indic.update(value);
}, ma);
\end{lstlisting}

Byla vytvořena třída \texttt{bazooka::indicator}, aby bylo možné objekt správně zapouzdřit a spravovat.
Třída má pouze jeden členský atribut \texttt{data\_} typu \texttt{std::variant<sma, ema>}, který je používán pro uložení indikátoru.
Metody používají \texttt{std::visit} pro přístup a změnu hodnoty indikátoru.
Sdílí stejné rozhraní s třídami \texttt{sma} a \texttt{ema}.

\chapter{Optimalizace}

\iffalse
Jednotlivé hodnoty jsou uloženy v instancích třídy \texttt{trading::fraction}, která je inspirována třídou \texttt{boost::rational}.
Je však mnohem jednodušší a méně obecná.
Předpokládá, na rozdíl od \texttt{boost::rational}, že zlomky, mezi kterými se provádějí aritmetické operace, mají stejného jmenovatele.
Porušení tohoto předpokladu vede k nedefinovanému chování.
Celá sekvence je uložena v instanci třídy \texttt{std::array}, což také znamená, že velikost sekvence musí být známa v době kompilace.
Pokud by to v budoucnu bylo nalezeno za nevhodné, může být nahrazena třídou \texttt{std::vector} nebo \texttt{boost::container::small\_vector} ke snížení počtu malých dynamických alokací.
\fi

\section{Návrh a generování stavového prostoru}
Pro optimalizaci byly vybrány 4 konfigurační proměnné: typ indikátoru, perioda indikátoru, úrovně a velikosti nákupů.
Hodnoty proměnných lze generovat buď systematicky, nebo náhodně.
Důležitým aspektem, který bylo nutné dodržet, bylo, že obě verze generátorů musí generovat hodnoty ze stejného vyhledávacího prostoru, jinak by byly výsledky jednotlivých optimalizačních metod nesrovnatelné.

Generátory sdílejí společné rozhraní, jakmile jsou vytvořeny, lze je použít voláním volacího operátoru třídy.
Náhodné generátory mají operátor přetížen.
Specializace přebírá jeden argument představující původní hodnotu používanou při generování následující hodnoty.
Systematické generátory vracejí korutiny a náhodné generátory vracejí přímo datové typy představující konfigurační proměnné.
Systematické generátory vracejí stejné hodnoty pouze jednou a náhodné generátory je mohou vrátit vícekrát.
V ideálním případě by měly náhodné generátory vracet stejné hodnoty se stejnou pravděpodobností.

\subsection{Typ indikátoru}
Typ indikátoru je reprezentován enumerační třídou \texttt{indicator\_tag} se dvěma možnými hodnotami: \texttt{indicator\_tag::ema} a \texttt{indicator\_tag::sma}.
Jediný způsob, jak parametrizovat tuto proměnnou, je použít buď jednu z hodnot, nebo obě.
Hodnoty jsou stejného typu, takže je lze uložit do pole.
Jelikož je jeho velikost malá a maximální velikost je známa v době kompilace, tak lze použít \texttt{etl::vector} k uložení hodnot pro generování.
Hodnoty lze náhodně rovnoměrně generovat pomocí instance třídy \tttext{std::uniform\_int\_distribution}.

\subsection{Perioda indikátoru}
SMA i EMA mají parametr perioda $p>1$.
Oba generátory generují hodnoty v intervalu $[f, t]$ s krokem $s$, kde $((f>t\implies((f-t) \mod s)=0 \land s<0) \land (t<f\implies((t-f) \mod s)=0 \land s>0)) \land s\neq0 \land t\neq f$.
Počet možných výstupních hodnot je roven $n=\frac{|t-f|}{s}+1$.

\subsubsection{Náhodné generování}
Při generování bez počáteční periody je nejprve pomocí \tttext{std::uniform\_int\_distribution} vygenerována hodnota $ v \in [\frac{p_{min}}{s}, = \frac{p_{max}}{s}$], kde $p_{min}=min(f, t) \land p_{max}=max(f, t)$, která je následně přeškálována $p_o=v\cdot s \land p_o \in [p_{min}, p_{max}]$.

Při generování hodnoty z počátku $o$ používá generátor navíc parametr $k\in[1,n/2]$.
Například, když $f=1$, $t=5$, $s=1$, $o=3$ a $k=1$, pak jsou všechny možné výstupní hodnoty periody $ p_o \in [o-(k\cdot s), o+(k\cdot s)]=[2, 4]$.
Jediné úskalí nastává na okrajích intervalu, kdy mohou být hodnoty generovány z 2 podintervalů. Například, když $f=1$, $t=5$, $s=1$ a $k=1$, pak jsou všechny možné výstupní periody $p_o \in [1, 2] \cup [5, 5]$.
Jelikož jsou periody generovány pomocí datového typu integer, který může nabývat i záporných hodnot, lze nejprve vygenerovat hodnotu $ w \in [o-(k\cdot s), o+(k\cdot s)]$, výslednou periodu získat $(w<p_{min}\implies(p_o=w+(n*|s|))) \land (w>p_{max}\implies(p_o=w-(n*|s|))) \land (w \in [p_{min}, p_{max}]\implies p_o=w)$.

\subsection{Úrovně nákupu}
Pro úrovně nákupu platí, že $\{l_0, l_1,\dots,l_n\} \in \mathbb{Q} \cap [0, 1] \land n>0 \land [\forall i \in \{0,\dots,n-1\} : l_i > l_{i+1}]$.
Příkladem takové sekvence racionálních čísel může být $\{\frac{1}{2}, \frac{1}{3}, \frac{1}{4}\}$.
Generátory jsou parametrizovány pomocí parametru $u\geq n$, který označuje počet jedinečných zlomků, které se mohou objevit v sekvenci.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=u+1$.
Pro $n=3$, $u=4$ jsou všechny možné platné sekvence: $\{\frac{4}{5}, \frac{3}{5}, \frac{2}{5}\}, \{\frac{4}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{4}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{2}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Sekvence jsou generovány rekurzivně (viz \ref{lst:systematic:levels_generator}), protože se počet smyček \texttt{for} liší v závislosti na velikosti sekvence $n$.
Smyčky jsou na sobě závislé, následující (hlubší) smyčka musí znát předchozí hodnotu čitatele.
Nejvnitřnější smyčka vrací výslednou sekvenci.

\begin{lstlisting}[caption={~Metody pro systematické generování úrovní nákupu},label={lst:systematic:levels_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_levels>
    requires (depth==n_levels)
    value_type generate(std::size_t) { co_yield this->levels_; }
    
    template<std::size_t depth = 0>
    requires (depth<n_levels)
    value_type generate(std::size_t prev_num)
    {
        for (std::size_t num{--prev_num}; num>n_levels-depth-1; num--) {
            this->levels_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}
Instance třídy \texttt{trading::random::levels\_generator} má mezi svými atributy pole se všemi možnými hodnotami výstupní sekvence.
Při generování náhodné sekvence bez počátku nejprve tyto hodnoty zamíchá, seřadí prvních $n$ prvků v sestupném pořadí a nakonec je zkopíruje do výstupního pole.

Náhodné generování na základě počáteční sekvence je složitější.
Používá parametr $k \in [1, n] $, který je předán instanci při její konstrukci.
Udává počet prvků počáteční sekvence, které by měly být změněny.
Při generování je nejprve náhodně vybráno $n-k$ prvků, které budou zachovány z původní sekvence, a jsou uloženy do instance \texttt{etl::flat\_set}, což je kontejner pevné velikosti, který ukládá jedinečné prvky v určeném pořadí.
Dále je zamícháno pole se všemi možnými hodnotami.
Ve smyčce \texttt{while} se pak hodnoty pokouší vložit do sady s jedinečnými hodnotami, dokud není sada plná.
Nakonec jsou hodnoty překopírovány ze sady do výstupního pole.

\subsection{Velikosti nákupu}
Pro velikosti nákupu platí, že $ (\-s_0, s_1,\dots,s_n)\ \in \mathbb{Q} \cap [0, 1] \land n>1 \land \sum_{i=0}^{n} s_i = 1 $.
Příkladem takové sekvence může být $ (\frac{1}{4}, \frac{2}{4}, \frac{1}{4})\ $.
Generátory jsou parametrizovány pomocí parametru $u\geq 1$, který označuje počet jedinečných zlomků, které se mohou v sekvenci objevit.
Zlomky, které tvoří výslednou sekvenci, jsou brány z množiny $\{\frac{u}{d}, \frac{u-1}{d},\dots, \frac{1}{d}\} \in [0, 1] \land d=n+u-1$.
Pro $n=3$, $u=3$ jsou všechny možné platné sekvence: $\{\frac{1}{5}, \frac{1}{5}, \frac{3}{5}\}, \{\frac{1}{5}, \frac{2}{5}, \frac{2}{5}\}, \{\frac{1}{5}, \frac{3}{5}, \frac{1}{5}\}, \{\frac{2}{5}, \frac{1}{5}, \frac{2}{5}\}, \{\frac{2}{5}, \frac{2}{5}, \frac{1}{5}\}, \{\frac{3}{5}, \frac{1}{5}, \frac{1}{5}\}$.

\subsubsection{Systematické generování}
Velikosti nákupů \ref{lst:systematic:sizes_generator} jsou systematicky generovány podobně jako úrovně nákupů.
Používá se také rekurze, každá smyčka \texttt{for} předává součet zbývajících čitatelů následující smyčce.
Maximální lokální čitatel má buď hodnotu globálního maximálního čitatele, nebo součet zbývajících čitatelů snížený o jedna.

\begin{lstlisting}[caption={~Metody pro systematické generování velikostí nákupu},label={lst:systematic:sizes_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
    value_type operator()()
    {
        co_yield generate<0>(this->denom_);
    }

private:
    template<std::size_t depth = n_sizes>
    requires (depth+1==n_sizes)
    value_type generate(std::size_t remaining)
    {
        this->sizes_[depth] = fraction_t{remaining, this->denom_};
        co_yield this->sizes_;
    }

    template<std::size_t depth = 0>
    requires (depth+1<n_sizes)
    value_type generate(std::size_t remaining)
    {
        std::size_t max = (remaining>this->max_num_)
            ? this->max_num_ : remaining-1;
        for (std::size_t num{1}; num<=max; num++) {
            this->sizes_[depth] = fraction_t{num, this->denom_};
            co_yield generate<depth+1>(remaining-num);
        }
    }
\end{lstlisting}

\subsubsection{Náhodné generování}

\section{Optimalizátory}

Když jsou volány heuristické optimalizátory, tak přijímají mezi objekty typu pozorovatel jako své argumenty.
Pozorovatelé jsou upozorňovány na události, ke kterým dochází během optimalizace.
Průběh optimalizace mohou hlásit nebo ukládat.
Příkladem události, která může nastat během optimalizace simulovaného ochlazování, je snížení teploty nebo přijetí lepšího stavu.
Pozorovatelé jsou vždy posledním parametrem uloženým jako sada parametrů šablony.
Tímto způsobem lze přijmout více pozorovatelů nebo žádný.

\subsection{Hrubá síla}
Algoritmus hrubé síly prochází celým vyhledávacím prostorem a zajišťuje nalezení optimálního řešení.
Je vhodný pro relativně malé vyhledávací prostory a může pomoci lépe porozumět vlastnostem cenové funkce.

Vyhledávací prostor je generován pomocí systematických generátorů, které jsou volány ve vnořených smyčkách \texttt{for} (viz \ref{lst:systematic:states_generator}).
Nejvnitřnější cyklus vrací konfiguraci jako korutinu typu \texttt{cppcoro::generator}.
Vytvoření vyhledávacího prostoru tímto způsobem je jednodušší než navrhování vlastního iterátoru, protože smyčky mohou být na sobě závislé.

\begin{lstlisting}[caption={~Ukázka generování systematického stavového prostoru},label={lst:systematic:states_generator},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
auto search_space = [&]() -> cppcoro::generator<config_type> {
    for (std::size_t period: periods_gen())
        for (const auto& tag: tags)
            for (const auto& levels: levels_gen())
                for (const auto& open_sizes: sizes_gen())
                    co_yield config_type{tag, period, levels, open_sizes};
};
\end{lstlisting}

Vzhledem k tomu, že jsou jednotlivé stavy na sobě nezávislé, může být vyhledávání paralyzováno.
Paralelizaci lze provést pomocí direktiv z knihovny \textit{OpenMP}.
Jelikož je vyhledávací prostor předáván jako korutina, lze jej paralelizovat pouze pomocí taskového paralelismu použitím direktivy \texttt{task}.

Implementaci paralelizace lze vidět ve výpise \ref{lst:brute-force}.
Nejprve je použita direktiva \texttt{parallel} k vytvoření paralelního regionu, který vytváří, provádí a ukončuje jednotlivá vlákna.
Následně je pomocí direktivy \texttt{single} proveden cyklus \texttt{for} právě jedním vláknem.
Uvnitř cyklu jsou vytvářeny jednotlivé úlohy pomocí direktivy \texttt{task} a prováděny paralelně jednotlivými vlákny.
Každé vlákno nejprve zavolá cenovou funkci k získání ceny.
Vytvoří stav, který se skládá z konfigurace a ceny.
Pokud stav splňuje omezující podmínky, je v kritické sekci výsledek aktualizován.
Je nutné použít synchronizaci, protože je výsledek modifikován více vlákny.
Algoritmus je zapouzdřen ve třídě \texttt{brute\_force::parallel::optimizer}.

\begin{lstlisting}[caption={~Optimalizace pomocí algoritmu hrubé síly},label={lst:brute-force},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
#pragma omp parallel
{
    #pragma omp single
    {
        for (const auto& config: search_space()) {
            #pragma omp task
            {
                auto curr_state = state{config, cost(config)};
                if (constrains(curr_state)) {
                    #pragma omp critical
                    result.update(curr_state);
                }}}}}
\end{lstlisting}

\subsection{Simulované ochlazování}
Algoritmus simulovaného ochlazování je implementován třídou \texttt{simulated\_annealing::optimizer}.
Třída má pouze několik členských atributů: současnou, počáteční a minimální teplotu, počet iterací a současný stav.
Jiné části algoritmu jako chlazení, ohodnocení horšího stavu a nalezení sousedního stavu jsou specifické pro řešený problém, proto jsou předány jako argumenty při volání instance objektu.

Bylo implementováno několik chladicích algoritmů vycházejících ze srovnávajícího článku \cite{cooling-comparison}.
Všechny jsou umístěny v souboru \texttt{simulated\_annealing/cooler.hpp}.
Většina je parametrizována parametrem decay, který se používá k řízení rychlosti snižování teploty.
Správnost jeho hodnoty závisí na algoritmu chlazení a ověřuje se při inicializaci konkrétního objektu.
Chladiče používají návrhový vzor strategie, který funguje následovně, namísto předávání seznamu argumentů při volání chladiče je jako argument předán samotný optimalizátor.
Algoritmus chlazení si tak může sám zvolit, které atributy heuristiky použije k výpočtu následující teploty a změnit její hodnotu může pomocí setteru třídy.
Příklad implementace chladiče lze vidět na \ref{lst:cooling}.

\begin{lstlisting}[caption={~Ukázka implementace chlazení třídy \texttt{simulated\_annealing::exp\_mul\_cooler }},label={lst:cooling},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
void operator()(SimulatedAnnealing& optimizer)
{
    optimizer.current_temperature(optimizer.start_temperature()*
        std::pow(this->decay_, optimizer.it()));
}
\end{lstlisting}

Volající operátor optimalizátoru přebírá většinu parametrů jako koncepty.
Výhodou použití konceptů namísto klasických šablonových argumentů je to, že lze definovat omezení, která musí předaný objekt dodržovat.
U volatelných argumentů lze například pomocí konceptů definovat typy vstupních a výstupních argumentů.
Koncept definující omezení pro chladící algoritmu lze vidět na \ref{lst:cooling:concept}.
Chyby generované kompilátorem při použití objektu se špatným rozhraním jsou často čitelnější a přímější při použití konceptů než samotných šablon.

\begin{lstlisting}[caption={~Koncept pro kontrolu chladícího algoritmu},label={lst:cooling:concept},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
template<class ConcreteCooler, class SimulatedAnnealing>
concept Cooler = std::invocable<ConcreteCooler, SimulatedAnnealing&> &&
std::same_as<void,std::invoke_result_t<ConcreteCooler,SimulatedAnnealing&>>;
\end{lstlisting}

Algoritmus pro nalezení náhodného souseda je implementován pomocí třídy \texttt{bazooka::neighbor}.
Ke generování sousední konfigurace využívá náhodné generátory, které na základě aktuální hodnoty generují následující hodnotu.
Náhodně je vždy změněn pouze jeden konfigurační parametr.
Pro realizaci equilibria byl implementován algoritmus založený na pevném počtu prohledávaných sousedních stavů \texttt{simulated\_annealing::fixed\_iteration\_equilibrium}.

Implementaci algoritmu lze vidět ve výpisu \ref{lst:simulated:annealing}.
Během optimalizace dochází k několika událostem, které jsou hlášeny pozorovatelům.
Pro sběr dat o průběhu optimalizace byla implementována třída \texttt{simulated\_annealing::progress\_collector}.
Za účelem logování byla vytvořena třída \texttt{simulated\_annealing::progress\_reporter}.

\begin{lstlisting}[caption={~Implementace simulovaného ochlazování},label={lst:simulated:annealing},captionpos=t,abovecaptionskip=-\medskipamount,belowcaptionskip=\medskipamount,language=C]
curr_state_ = state{init_config, objective(init_config)};
(observers.begin(*this), ...);

for (; curr_temp_>min_temp_; it_++) {
    while (equilibrium()) {
        Config config = neighbor(curr_state_.config);
        auto candidate = state{config, objective(config)};

        if (result.compare(candidate, curr_state_)) {
            curr_state_ = candidate;
            (observers.better_accepted(*this), ...);

            if (constraints(curr_state_))
                result.update(curr_state_);
        }
        else {
            double diff = appraiser(curr_state_, candidate);
            double threshold = std::exp(-diff/curr_temp_);

            if (rand_prob_gen_()<threshold) {
                curr_state_ = candidate;
                (observers.worse_accepted(*this, threshold), ...);
            }
        }
    }
    cooler(*this);
    (observers.cooled(*this), ...);
}
(observers.end(*this), ...);
\end{lstlisting}



